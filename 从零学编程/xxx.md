编程范式  
编程语言  
语言特性 抽象：过程抽象、功能抽象 数据抽象
设计模式 （六大原则）
并发 锁 内存管理 线程 gc
容器 异常 io 元编程
编译知识：虚拟机 解释器 编辑器 


就是为了实现抽象，而封装 多态是手段  继承是多态的一种

继承是否能被接口、协议 委托 混入等概念替代
继承的问题：最小知识原则, 开闭原则,里氏替换原则,  逆变协变双变抗变 多继承菱形继承
访问权限关键词 构造函数顺序地狱
继承会导致耦合 父类和子类天然是耦合的
满足is a条件是继承的前提，但是在实际的业务开发中，你不可能保证
我们使用面向对象是为了对现实世界进行建模
但是一个对象的功能不仅是由它的类型来决定的，还由如何被使用决定，所以你需要一个scope
这就像DDD中的上下文

组合的has-a

继承的作用是复用代码  也是多态的体现
什么时候使用方法重写



实现oop 除了常见的基于类的实现(class-based），另一种实现则基于原型prototype-based，而他最大的发扬者就是使用率很高的一门语言JavaScript;
函数和对象绑定，而不是和类绑定，天生就实现了dynamic dispatch
沿着原型链查找属性和方法，同样实现了代码复用，复制自同一原型的对象，也具有相同的子结构


继承是消息传递吗？
OOP的重点是“消息"对于外部世界来说，刻画一个对象的是它与其它对象如何通过消息交互。不是这个对象属于那个类，不是这个类又继承了那个类，也不是它到底class based还是prototype-based
比如Erlang实际上是一个进程间用OOP方式组织，进程内用FP实现的语言。而整个Web，以服务器为对象，以HTTP Request互相发消息，实际上是世界上最大的软件系统，同样是基于OOP风格构造

关于oop和并发
问题是object会保有自己的状态，这是在并发时遇到问题的原因



什么是封装？ 访问修饰符？
不是，是做出好的抽象 对外提供 完整且最小的接口 使得对象成为一个黑盒，


不使用继承 如何实现多态和代码复用


抽象类和接口的区别？
语法层面上和设计层面上
语法层面：1.抽象类单继承 接口多实现 2.接口里面的变量默认是public static final（常量）的 抽象类中的是任意类型的（接口无状态 抽象类有状态）
本来接口都是抽象方法 但是1.8新增接口的静态和默认方法

设计层面：抽象类是一种约束，语义是is -a , 接口则更加灵活,**接口定义行为，而不指定任何实现细节**（例如菜单给出了可以提供的菜品种类，但是实现细节没有定义的）



接口的默认方法：设计目的是让已经存在的接口可以演化——添加新方法而不需要原本已经存在的实现该接口的类做任何改变


接口interface和混入mixin
接口用于定义类之间的契约，而混合用于向类添加功能
在编译层面，





SOLID
单一责任原则(SRP) : 一个类应该只有一个改变的理由。
开闭原则(OCP) : 软件应该对扩展开放，但对修改关闭。
Liskov代换原则: 子类应该完全可以替代他们的父类。
接口隔离原则: 大型接口分解为更小、更具体的接口
依赖反转原则: 高级模块不应依赖于低级模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。
