​**Redis为什么单线程模型依然高效**

**Redis支持哪些数据类型？分别举例应用场景**

Redis的数据结构实现，如SDS、压缩列表、跳表等

**RDB和AOF持久化的优缺点对比**

**缓存雪崩、穿透、击穿的成因及解决方案**

**如何保证Redis与数据库的数据一致性**（cache aside write through  write back）

**如何处理Redis热点Key**

**Redis大Key的危害及处理方法**

**Redis主从复制流程及哨兵机制的作用**

**Redis分布式锁的实现方案及缺陷**

Redis分布式一致性？

**主从复制的全量同步和增量同步流程，哨兵选举流程，以及脑裂问题**

​**Redis渐进式Rehash过程如何实现**

主从哨兵集群

redis的过期策略 
（定期删除+惰性删除 +内存淘汰机制兜底）


主从复制的流程
哨兵模式的原理
集群是如何分片的         Redis 采用 **哈希槽（Hash Slot）** 进行数据分片，每个节点负责一部分哈希槽 扩容时添加新节点重新分配哈希槽。
集群的高可用  通过 **主从复制** 保证高可用，集群中的每个主节点一般都有至少一个从节点  
采用 **Gossip 协议** 进行故障检测，若主节点宕机，从节点自动升级为主节点

redis的CAP 哨兵CA 集群AP
脑裂问题如何解决
redis是什么一致性
LRU LFU

redis会出现一致性问题吗 如何出现的 如何解决
Redis 采用 **异步复制**，主节点不会等待从节点确认，因此可能存在数据未同步完成就发生主从切换的情况。此外，网络分区、主从之间的数据延迟等也会导致数据不一致

Redis 哨兵模式如何判断主节点故障



### **10. Redis 为什么单线程却能高性能运行？**

> 解析：
> 
> - **内存操作快**：所有数据在内存中，避免了磁盘 I/O。
> - **避免上下文切换**：单线程不涉及多线程的锁竞争，减少 CPU 开销。
> - **高效的事件驱动模型**：Redis 使用 **epoll/kqueue** 进行 I/O 多路复用，实现高吞吐。
> - **操作都是 O(1) 或 O(logN)**：大多数 Redis 命令执行时间复杂度较低，避免性能瓶颈。


### **Redis AOF 和 RDB 的区别？如何优化持久化策略？**

> 解析：
> 
> - **RDB**（快照）：适合快速恢复数据，性能开销小，但可能会丢失最近的数据。
> - **AOF**（追加日志）：保证数据完整性，但日志文件较大，恢复较慢。
> - **最佳实践**：
>     - 结合 **AOF+RDB**，即 `appendfsync everysec` 模式，每秒写入 AOF 并定期触发 RDB 快照。
>     - 开启 `lazy-free` 机制，减少大 key 删除的阻塞影响。


### **Redis 如何防止缓存击穿、缓存雪崩和缓存穿透？**

> 解析：
> 
> - **缓存击穿**（热点 key 失效）：
>     - 采用 **互斥锁** 或 **预加载** 机制，防止并发查询数据库。
> - **缓存雪崩**（大量 key 同时失效）：
>     - 采用 **不同失效时间**（加随机值），避免所有 key 同时失效。
>     - **使用持久化存储**，防止 Redis 宕机时数据丢失。
> - **缓存穿透**（查询不存在的数据）：
>     - 采用 **布隆过滤器（Bloom Filter）** 拦截无效查询。
>     - 返回 **空值并设置短 TTL**，避免数据库压力过大。









内存操作 单线程 数据结构 IIO多路复用


string hash list set zset   bitmap 

缓存对象、常规计数、分布式锁
消息队列
缓存对象
（并集、交集、差集） 体现在业务场景就是共同关注 多个商品标签的共同结果  
排行榜




大key：
key对应的value值太大

redis的工作进程是单线程 在操作大key时耗时很久


业务逻辑中处理掉 拆分、序列化


热点key：
占用大量的cpu和带宽 甚至宕机

读写分离
数据分片 
本地缓存




扩容时同时维护新旧两个哈希表，逐步迁移键值对，避免单次操作阻塞
