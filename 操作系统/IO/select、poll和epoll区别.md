-   select版宿管阿姨，带着你的朋友挨个房间找，直到找到你
-   epoll版阿姨，会先记下每位同学的房间号， 你的朋友来时，只需告诉你的朋友你住在哪个房间，无需亲自带着你朋友满大楼逐个房间找人

**1.select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。（需要遍历fd_set才能知道哪个就绪了 同时fd数组长度是个常量 所以数量有限）

2.poll本质上和select没有区别（只是描述fd集合的方式不同），它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的.

3.**epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。**（复杂度降低到了O(1)）**

epoll不会和select、poll 一样去傻傻地轮询所有fd，这样太消耗时间



select，poll，epoll都是I/O多路复用机制，即能监视多个fd，一旦某fd就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质都是**同步I/O**，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O实现会负责把数据从内核拷贝到用户空间。

  

轮询I/O是最耗时操作之一，因此，epoll的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。




![[Pasted image 20221214213422.png]]


![[Pasted image 20221214213933.png]]





![[Pasted image 20221214215408.png]]


![[Pasted image 20221214215428.png]]




