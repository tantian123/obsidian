
函数调用及汇编指令
函数的调用分为两个步骤：调用和返回
分别在汇编中是call和ret指令

call的步骤：1.将ip或cs压入栈中
2.跳转

ret指令的步骤：1.将栈中的地址弹出到IP寄存器
2.跳转执行后续代码

函数的调用，传递参数都是通过寄存器


------------------------


函数调用栈的主要内容

函数参数表、局部变量表、栈的基址和函数返回地址




为什么用栈，因为函数调用返回后，还要恢复原函数栈的状态



协程可以看作是**轻量级的线程**，也是**用户态的线程**。

**用户态**是指协程的切换完全是在用户态进行的，而不会陷入内核。协程的调度完全取决于用户的实现方式，而与操作系统的调度无关。
而且协程的切换是在用户态的，不会陷入内核，因此协程切换的开销也是相当小的。后面会讲到，协程的切换无非是改变几个寄存器的值即可。
正是因为协程的这种特性，使得协程更加适用于**IO密集型**的任务中，因为IO通常会伴随着大量的阻塞等待过程，而使用协程就可以在IO阻塞的同时让出CPU，而当IO就绪后再主动抢占CPU即可。





协程不过是一段子程序(其实也就是个函数)罢了，因此只要保存下当前的函数栈状态、寄存器值，就可以描述出这个协程的全部状态，这个结构被称为协程上下文。

协程上下文其实就是保存了当前所有寄存器的值，这些寄存器描述了当前的函数栈，程序执行状态等信息。

## 协程切换

有了协程上下文之后，协程切换就很容易理解了。协程切换只需要两步就够了：

1.  保存当前寄存器的值到协程上下文中的regs数组；
2.  将新协程上下文的regs数组中值取出来赋值给对应的寄存器




## 有栈协程和无栈协程区别
goroutine是有栈协程 不同协程间切换还是要切换对应的栈上下文，只是不用陷入内核而已
js，c++，rust 那种 await，async 实现的协程是无栈协程

**所谓的有栈，无栈并不是说这个协程运行的时候有没有栈，而是说协程之间是否存在调用栈（callbackStack）**


## 有栈协程

实现一个协程的关键点在于如何**保存、恢复和切换上下文**。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧和寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的函数的上下文。有栈协程便是这种朴素思想下的产物。

但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。


  
## 无栈协程

无栈协程的本质就是**状态机**，yield的本质就是状态转移

相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换

无栈协程思路的演变：  
generator（yield）-> future/promise -> async/await；越来越易用。

主要原理就是闭包+异步，换句话说，其实就是协程的上下文都放到公共内存中，协程切换时，使用状态机来切换，就不用切换对应的上下文了，因为都在堆里的。比有栈协程都要轻量许多



## 为什么要使用协程 好处在哪

[有栈协程](https://www.zhihu.com/search?q=%E6%9C%89%E6%A0%88%E5%8D%8F%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2294018082%22%7D)就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换[栈空间](https://www.zhihu.com/search?q=%E6%A0%88%E7%A9%BA%E9%97%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2294018082%22%7D)和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。



## go协程
由编译器完成，比如 Golang 使用`go`关键字修饰一个普通函数后，这个函数就变成了一个有栈协程。