前一章描述了在同一台计算机上调度的容器集合的分组模式。这些群体是紧密结合的共生系统。它们依赖于本地的共享资源，如磁盘、网络接口或进程间通信

**可靠性、可伸缩性和关注点**分离决定了现实世界中的系统是由许多不同的组件构成的，分布在多台机器上。与单节点模式相比，多节点分布式模式耦合更加松散。


复制服务

无状态服务
无论您的服务有多小，您都需要至少两个副本来提供具有“高可用性”服务水平协议

会话追踪服务
有理由希望确保特定用户的请求总是在同一台计算机上，因为您在缓存内存中的用户数据可以确保更高的缓存命中率

会话跟踪是通过一致哈希函数完成的。当服务的规模扩大或缩小时，一致哈希功能的好处就变得显而易见。显然，当副本数量发生变化时，特定用户到副本的映射可能会发生变化。一致哈希函数可以最小化实际更改映射到的副本的用户数量，减少扩展对应用程序的影响。


部署 web 缓存的最简单方法是使用 Sidecar 模式在 Web 服务器的每个实例旁边


=========

共享服务
复制服务通常用于构建无状态服务，而分片服务通常用于构建有状态服务
分片数据的主要原因是状态的大小太大，单台机器无法处理。分片使您能够根据需要服务的状态的大小来扩展服务。
如何将流量路由到不同的分片
分片函数非常类似于哈希函数
基于桶的散列表可以被视为分片服务的一个例子

通常，分片函数是使用散列函数和模(%)运算符定义的。散列函数是将任意对象转换为整数散列的函数。散列函数对于分片有两个重要特征:
对于唯一的输入，输出应该始终相同。
输出在整个输出空间的分布应该是相等的。

如何选择key：
考虑一个简单的 HTTP 请求，它包含三个内容:
请求的时间
来自客户端的源 IP 地址
HTTP 请求路径(例如/some/page.html)
如果我们使用一个简单的基于对象的哈希函数 shard (request) ，那么很明显{12:00,1.2.3.4,/some/file.html }与{12:01,5.6.7.8,/some/file.html }有一个不同的 shard 值。
分片函数的输出是不同的，因为客户端的 IP 地址和请求的时间在两个请求之间是不同的。当然，在大多数情况下，客户端的 IP 地址和请求的时间不会影响对 HTTP 请求的响应。因此，与散列整个请求对象不同，一个更好的分片函数应该是 shard (request.path)
当我们使用 request.path 作为分片key时，我们将两个请求映射到同一个分片，因此对一个请求的响应可以从缓存中提供，以服务于另一个请求。

为分片功能确定合适的键对于设计好分片系统至关重要。**确定正确的分片key需要理解您即将收到的请求**


为了解决这些问题，许多分片函数使用了一致哈希函数。一致哈希函数是一种特殊的哈希函数，当调整大小为 # shards 时，它保证只重新映射 # key/# shards。例如，如果我们对分片缓存使用一致哈希函数，从10个分片移动到11个分片只会导致重新映射 < 10% (K/11)键。这比丢失整个分片服务要好得多。

====
 Hot Sharding Systems
意思应该是动态分配




#### Scatter/Gather
与之前介绍的去中心化复制和分片数据模式不同的是，散播/收集模式使用了树形结构，并将请求分配给不同的节点进行处理

假设您需要为一个用户请求 R 提供服务，并且单个核心需要一分钟才能产生该请求的答案 A。如果我们编写一个多线程应用程序，我们可以通过使用多个内核在一台机器上并行处理这个请求。考虑到这种方法和30个核心处理器(是的，通常是32个核心处理器，但是30个核心处理器使数学更清晰) ，我们可以将处理单个请求的时间减少到2秒
此外，真正在单个进程上实现完全并行的加速将是棘手的，因为内存、网络或磁盘带宽开始成为瓶颈。我们可以使用分散/收集模式将请求并行化到多台不同机器上的多个进程，而不是将应用程序并行化到单台机器的多个核心上。

因为我们不再受一台机器上可以获得的核心数量的限制，同时**确保我们进程的瓶颈仍然是 CPU**



### 分布式锁
在使用分布式锁时，关键是要确保您所做的任何处理不会比锁的 TTL 持续更长时间。一个好的实践是在获取锁时设置看门狗计时器。看门狗包含一个断言，如果锁的 TTL 在您调用解锁之前过期，该断言将使您的程序崩溃。
