并发并行 并发是同时处理多件事dealing with 并行是同时做多件事 doing

经常混淆并发和并行的原因是：线程与锁的并发模型 并没有显式地支持并行，它是并行地运行在多核上的

讲讲硬件：
为什么多核而不是多个cpu 因为核心在同一个芯片上 通信成本更低

CMP 多核的处理器 每个核心可以独立完成任务
SMT   单个核心能够同时执行多个线程（单个核心内有多个执行单元，例子是超线程）
SMP  对称多处理器   多个物理处理器共享一个操作系统和内存空间,通常在服务器中使用，多个cpu共享内存和io资源，提高计算能力
NUMA 每个多核处理器可能有自己的本地内存区域和访问远程内存的能力
ILP  指令级并行 在单个核心中并行执行多条指令来提高性能，现代处理器都采用了这种技术即指令乱序并行执行

并行的层级：
指令级 ：单个处理器核心内部并行执行多条指令，现代cpu都使用了这种技术，即流水线和乱序执行（超线程）
数据级：同一指令对多个数据进行操作 即GPU
线程级 ：多线程
核心级 ：多核cpu
处理器级 :使用多个处理器，例如服务器
系统级：

## 线程与锁
在这个模型下，线程通过共享内存进行通信
所以通过锁进行线程互斥



#### 线程与锁带来的三个并发问题：竞态条件 内存可见性 死锁

###### 竞态条件
多个线程同时对 count 进行递增操作，可能导致竞态条件，即多个线程同时读取 count 的当前值，然后进行递增操作，最后将结果写回 count。这可能会导致一些递增操作被覆盖，从而造成 count 的值不是期望的值

解决方案是对count进行同步访问，使用锁（也叫互斥锁 管程 或者是临界区）

###### 内存可见性
编译器JVM硬件会插手原本的代码逻辑
编译器的静态优化 JVM的动态优化 硬件的乱序执行

###### 死锁
多线程程序通过上多把锁让所有的方法都变为同步的，这不仅会效率低下，也会带来死锁的问题

例如哲学家进餐问题 左手的筷子和右手的筷子

#### 监听器模式带来的危害
外部方法可能也会持有一把锁 这就可能导致死锁
唯一的解决方案是 避免在持有锁的时候调用外部的方法


## 内置锁的替代方案

##### Reentrantlock
synchronized可以被Reentrantlock替代

可以通过设置超时时间来解决哲学家进餐问题 tryLock
##### 条件变量condition
用于等待事件发生  我们使用条件变量使某个条件为真
条件变量需要与锁关联
```
ReentrantLock lock=new ReentrantLock();
Condition c=lock.newCondition();
lock.lock();

try{
while(!条件为真) {// 如果不为真 会一直调用await
	condition.await();}
	
	使用共享资源
}finally{lock.unLock();}

```


##### 原子变量
基础是CAS无锁非阻塞
好处是不会忘了加锁 不会死锁 内存可见性的问题也没了

关于volatile变量
是一种低级形态的同步，不能解决count++的问题，适用的场景也随着锁的优化而变少，应该有更实用的工具来替代它



## 并发工具
优化一个读取文本的程序 分别使用了
生产者消费者模型（并发工具ArrayBlockingQueue）
并行的思想->统计同步的map（ConcurrentHashMap ConcurrentHashMap的putIfAbsent和replace取代put方法）
使用线程池
解决消费者的竞争问题(过度竞争导致 运行时间反而增加 )->先分别计算 再汇总

这个过程并没有使用显式地锁 而是通过并发工具来实现
##### 线程池


#### ArrayBlockingQueue
是一个并发队列，提供了高效的put和take方法，这些方法在必要时会阻塞




## 总结
优点 线程与锁模型的适用范围广 更接近硬件的本质 容易集成到编程语言中去
缺点 线程与锁模型并没有为并行提供直接的支持 编程语言没有提供足够的帮助
多线程的bug难以调试和发现

多线程编程的技巧与语言无关 基本上就是
访问变量时需要用同步的方式
按照固定顺序获取多把锁
持有锁时避免调用外部方法