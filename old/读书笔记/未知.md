Java持久性框架的不同特性的考虑
集成语言和数据库范例时，它们的一些独特优势可能会丢失，
在 Java 中，集成这两个世界的最系统的方法是通过使用框架
数据库和OOP范式 持久层框可以设计得更接近两个领域中的一个：

框架有各种类型和类别，这些类型和类别由它们的通信级别和提供的 API 决定

在通信层面
直接采用驱动程序的模式，（例如，JDBC驱动程序）意味着更接近数据库领域空间 易于使用的数据库驱动程序通常是面向数据的。一个缺点是需要有更多的样板代码来映射和转换数据库模型和Java领域对象之间的所有操作数据。

映射器模式，提供了将数据库结构映射到Java对象的完全相反的方法。在Hibernate和Panache等映射框架的上下文中，主要目标是更接近OOP范式，而不是主要关注数据库。虽然提供了减少样板代码的好处，但它必须与持续的对象关系阻抗不匹配及其相应的性能影响共存。





关系型数据库中获得的最好的优点之一就是能够使用结构化查询语言（SQL）
SQL代码是可移植的，相同的SQL代码在许多数据库系统上都可以工作，无需或只需少量修改
除此之外，SQL还有助于减少学习新语言或API（如Java的JDBC或JPA）的认知负担。

在Java中，我们有JDBC，这是一种我们可以一次学习并在任何地方编写/应用的语言。关系型数据库引擎是透明的，因此，JDBC和JPA将是相同的。

这些持久化技术的基本特性是与数据事务相关的属性：原子性、一致性、隔离性和持久性（ACID）。符合ACID属性的事务具有以下几个方面：
原子性：事务是一个原子单位。要么所有数据库操作作为一个单位发生，要么什么都不发生；这是一个“全有或全无”的操作。这可以防止部分数据更新和潜在的数据不一致。 一致性：当事务开始和结束时，数据库应处于一致的状态。事务应遵循每一个数据库约束和规则，以保证足够的一致性。 隔离性：一个事务不应对另一个操作产生负面或意外的影响。例如，一个表插入将生成一个表行ID，该ID被第二个操作使用。然而，我们不希望两个操作同时改变同一行。 持久性：事务完成后，一旦提交，更改将永久保留。即使在意外失败的情况下，也能确保数据的一致性。

NoSQL数据库提供了存储和检索非结构化数据（非关系型）的机制，这与关系型数据库中使用的表格关系形成了鲜明的对比。与关系型数据库相比，NoSQL数据库具有更好的性能和高可扩展性。它们在几个行业中越来越受欢迎，如金融和流媒体。由于这种使用的增加，用户和数据库供应商的数量正在增长。
与关系型数据库的ACID原则相反，在NoSQL世界中，关键特性是BASE（基本可用性、软状态和最终一致性）
基本可用性：高度的复制确保了即使发生多次故障，数据也能保持可用。 软状态：没有写一致性的要求，也不能保证复制的数据在节点之间是一致的。与传统的关系型数据库不同，更改可以在没有直接用户输入的情况下发生。 最终一致性：在检索（读取）数据时，可以懒惰地处理一致性。换句话说，数据最终会达到一致，所有节点将拥有相同的数据，但不一定是在同一时间。

NoSQL数据库类型
1.键值对
目前在市场上，这种方法的一些流行实现是Amazon DynamoDB、Hazelcast和Redis数据库，后两者都是开源技术
在这种数据库类型中，有一些新的概念需要注意，如bucket和键值对
总的来说，键值NoSQL是一种可以将数据存储为键值对集合的数据库，并针对存储大量数据和通过键有效检索数据进行了优化。它以易于使用和理解，以及水平可扩展性而闻名，这使得它成为需要高读写吞吐量的应用程序的好选择。

尽管有多种好处，但当涉及到数据建模和查询时，键值数据库可能比其他类型的NoSQL数据库的**灵活性较差**。它们不支持复杂的查询，没有丰富的数据模型，因此对于需要复杂数据操作的应用程序可能不太适合。此外，键值数据库**不支持事务**，这对于一些用例可能是一个限制。

2.文档型
NoSQL文档存储类型设计用于存储、检索和管理具有最小定义结构的文档，如XML和JSON格式。换句话说，一个没有预定义结构的文档是一个数据模型，可能由许多不同类型的数据字段组成

具体来说，文档NoSQL数据库选项易于使用，需要最小的设置，这使得它成为快速开发应用程序的快速原型设计的好选择
但是它通常缺乏事务支持，并且不提供像传统关系数据库提供的复杂多表连接能力那样复杂的查询能力

Amazon SimpleDB、Apache CouchDB和MongoDB都是流行的NoSQL文档类型存储解决方案

3.列数据库
这些数据库针对存储大量的结构化、半结构化和非结构化数据进行了优化，具有灵活的模式，并支持高并发性。
与其他类型相反，这种类型的数据库中的数据是以列而不是行存储的，允许更灵活和可扩展的数据模型。单个列族中存储的数据可以是不同类型和结构的
与其他NoSQL类型相比，这些数据可能更难查询，因为它们不是以传统的基于行的格式存储的。此外，模式灵活性的增加代表了数据模型设计和数据管理等任务的复杂性增加。

HBase和Cassandra都是开源的、分布式的、宽列NoSQL数据库
4.图数据库
NoSQL图数据库类型是为存储和查询具有复杂关系的数据而优化的。在这种方法中，数据被表示为一个图，其中节点代表实体，边代表这些实体之间的关系。
图NoSQL数据库解决方案非常适合需要快速查询高度互联数据的场景，如社交网络、推荐引擎和欺诈检测系统。尽管它们可以存储和检索大量的数据，但在面对大量的结构化和非结构化数据以及灵活的模式时，这并不总是成立，其中列族类型可能更合适。此外，复杂的查询可能需要遍历图以找到请求的数据片段。
有几种图数据库引擎可供选择，包括Neo4j、InfoGrid、Sones和HyperGraphDB

5.NewSQL数据库是一种混合数据库类型
结合了关系型和NoSQL两个世界的最佳特性，提供了存储和查询具有固定模式的结构化数据的能力，同时也提供了NoSQL数据库的可扩展性和灵活性特性。NewSQL被视为一种解决关系型和NoSQL范例限制并为现代应用程序提供更灵活和可扩展解决方案的方式。

NewSQL试图提供水平可扩展性，同时保持ACID（原子性、一致性、隔离性和持久性）原则的保证
以下是一些NewSQL数据库的例子：
VoltDB ClustrixDB CockroachDB




不同架构选项（如微服务和单体应用）的利弊
单体架构 构建解决方案的传统方式是使用单体应用，这些应用是大型的、独立的软件系统，作为单一的、有凝聚力的单元构建，所有组件都包含在一个包中，并一起编译、管理和部署
这意味着前端和后端都包含在同一个工件中，必须一起编译、管理和部署。虽然这种方法可以使最初开发和维护应用程序变得更容易，但随着团队的增长，代码的维护变得更复杂，部署更新变得更具挑战性和耗时。
从性能角度来看，可伸缩性受到影响，因为很难对特定的功能或组件进行升级或降级。
定义数据库和单体之间的关系并不是一项复杂的任务。有些人选择开发单体，而不是巨大的数据库，这些单体存储和消费来自多个数据库的数据 - 进一步增加了维护的复杂性

面对由SOA方法启发的单体设计的缺点，微服务的概念开始发挥作用。微服务提出将组件/模块解耦为更小的服务，每个服务都有自己独特的责任。
尽管微服务涉及到管理更多的故障点，但成功的实施可以带来诸如独立团队、更改、部署和扩展生态系统中的每个服务的好处，而不会影响其他微服务。
可以采用各种通信模式（包括REST、GRPC和异步事件等）和集成模式。使用面向微服务的架构可以更快、更常规地交付，同时引入一个不受语言限制的生态系统

开发人员应该不仅要考虑微服务架构的一组核心特性，还要考虑可能对项目构成巨大风险的关键元素，例如以下几点：
集成延迟 职责分离  服务大小和责任 被遗忘的服务  粒度细化的仓库

持续集成和持续部署（CI/CD）是微服务的最佳实践，对于管理部署在多个部署环境中的多个服务至关重要，范围从本地机器到云服务。

有一个问题：双写反模式 
有很高的可能性最终导致数据不一致和完整性问题，因为无法确保两次写入都能成功完成或者都不完成，就像在一个单一的事务中一样。
所以：一个服务不应直接更改另一个服务拥有和消费的任何数据
一个服务不应负责或对跨多个数据存储解决方案的数据持久性和一致性的操作和维护负责

事件驱动架构（EDA）：
围绕事件驱动模式的技术被创建出来，以允许数据库 - 即使是传统的数据库 - 具有新的能力：发出事件。你没看错，传统的关系数据库（以及其他数据库）有可能超越基础，让开发者依赖变更数据捕获

## mapper pattern
Book类 
BookMapper 层集中了数据库模型和应用程序实体模型的映射操作
```
class BookMapper {    private Database database = Database.INSTANCE;
    public Optional<Book> findById(String id) {
        Objects.requireNonNull(id, "id is required");
        return database.findById(id)
                .map(entity());
    }
```
如何创建一个新层，但是这一次，让它作用于整个数据库操作？
## The DAO pattern
DAO模式
DAO 模式是一种将应用程序/业务层与持久层分离的结构化方法。它的主要目标是从 API 中抽象出整个数据库操作。
通过将所有操作封装在类或接口中，可以在需要时更新 API，而不会影响持久性数据实现。这在需要更改 DAO 实现的长期系统中尤其有用。
```
public interface BookDAO {    Optional<Book> findById(String id);
    void insert(Book book);
    void update(Book book);
    void deleteByTitle(String title);
}
public class BookMemory implements BookDAO {//..
    @Override
    public void update(Book book) {
     mapper.update(book);
    }
//…
}
```

目标是使用抽象隔离数据库，因此无论您使用的是 SQL、 NoSQL 还是任何服务都不重要

通过DAO模式  我们得到了隔离和更好的可维护性


但是如果客户端尝试插入两次或更新不存在的信息，我们将再次引发异常。这是一个在某些情况下可能没有意义的数据库细节。那么，我们如何才能消除这种情况，更多地关注于业务呢？这就是我们将在下一节讨论的存储库模式和领域驱动设计(DDD)实践。



## Repository pattern boosted by DDD
DAO 和Repository模式实现之间的主要区别在于客户端和数据库之间的距离，通常称为接近度。虽然 DAO 公开了持久层的行为，但是Repository模式倾向于公开面向业务的行为。



MAPPER PATTERN的框架 ： Spring Data
![[Pasted image 20231120220126.png]]



## The active record pattern
是降低在模型中使用数据库操作的复杂性的一种方法
此模式背后的思想是通过拥有一个扩展 Model 类的实体来在 Java 中使用继承。这使得实体数据库具有类似于拥有超级能力的模型的能力

```
public class Book extends Model {    private final String title;
    private final String author;
    private final String publisher;
    private final String genre;
}
```
这模式有其自身的问题，如违反 SOLID 的单一责任原则。一些 Java 框架依赖于这种模式


获取数据的途径不同 框架也不同：
通信: 离数据库更近，离领域模型更远; 这支持数据驱动设计，但可能有更多的样板代码。

映射: 离模型更近，离数据库更远; 这支持 DDD 并减少样板代码，但是离数据库更远会导致忽略数据库方面的最佳实践。



DTO 是一种设计模式
它促进了系统层或组件之间的数据传输。它可以用来将表示层与业务逻辑分离
这些简单的对象包含数据，但没有相关的业务逻辑

关键是要记住，隔离是关键，过多的代码会增加复杂性并影响性能。
创建 DTO 可以表示大量工作，特别是在手动实现时。幸运的是，如果您认为 DTO 模式非常适合您的项目，那么市场上有一些框架可以使您的工作更加轻松。



### 构建时反射
反射在 Java 编程和框架中是一种强大的机制。它支持动态代码执行、元数据提取以及对配置和自定义的注释的利用。虽然反射可以影响特定场景中的启动性能，但是 Quarkus 和 Micronaut 等框架已经引入了构建时反射作为解决方案，允许开发人员在不牺牲性能的情况下利用注释的好处。由 CDILite 启用的这种方法促进了 Java 在无服务器和云本机环境中的有效使用




everything has a trade-off!




Cassandra
docker run -d --name cassandra-instance -p 9042:9042 cassandra


如果您正在使用一个不可变的值对象，那么使用它来探索 Java 中的最新特性是一个非常好的选择: record

JOOQ，代表面向Java对象查询，是一个轻量级但是健壮的 Java 库，它使开发人员能够流畅而直观地编写类型安全的 SQL 查询。它提供了一个领域特定语言(DSL)来封装 SQL 的复杂性，允许开发人员专注于编写简洁和可读的代码。
JOOQ 使开发人员能够在 Java 代码中充分利用 SQL 的强大功能，提供灵活性、性能和可维护性，而这些通常难以用传统的对象关系映射(ORM)框架实现。

数据驱动编程和面向对象编程的关键区别在于它们的程序设计方法。在 OOP 中，重点是对实体及其行为进行建模，围绕对象及其交互组织代码。当对象的行为很复杂或者需要表示系统中的实际实体时，这种方法可以很好地工作。

另一方面，数据驱动编程优先处理操作和处理数据结构。在处理大量数据(如数据库或以数据为中心的应用程序)时，它是有益的。数据驱动的编程允许有效地查询、过滤和转换数据，通常利用 SQL 或其他查询语言等声明性方法。

在 jOOQ 和 JPA 之间做出选择取决于您的具体项目需求。如果您的应用程序是数据密集型的，需要复杂的查询，并且需要对 SQL 进行细粒度控制，那么 jOOQ 可能是更好的选择。另一方面，如果你优先考虑面向对象设计、跨不同数据库的可移植性和快速的应用程序开发，JPA 可能是更合适的选择。同样值得考虑的是混合方法，可以在应用程序的不同部分同时使用 jOOQ 和 JPA，根据需要利用每个库的优势。


Java、 Python 和 C # 等面向对象语言使用对象来表示和操作数据，而关系数据库使用表来存储和管理数据。ORM 是一种通过将对象映射到数据库表来弥合这两种不同范例之间的差距的技术，反之亦然

Eclipse Store 是一种基于 Java 的开源内存数据存储技术，它提供了一种新的对象持久化方法。

与依赖 ORM 将对象映射到关系表的传统数据库不同，Eclipse Store 的内部机制定位并使用堆上可用的 Java 对象。它可以直接从内存中获取信息，无需映射或序列化。这种方法可以提高应用程序的性能，因为它避免了 ORM 阻抗不匹配，并减少了对昂贵的数据库访问的需求
Eclipse Store 主要在内存中运行; 因此，它可以提供对数据的超快读写访问，使其成为高性能数据处理应用程序(如实时分析、金融交易和游戏)的理想选择。

除了速度和性能方面的好处，Eclipse Store 还提供了高度的灵活性和可伸缩性。它支持分布式数据结构，允许数据跨多个节点分布，并与其他数据库或数据源集成。

Eclipse Store 是一种数据存储解决方案，由于删除了映射过程、对查询进行解析操作、避免了传统查询执行的缺点，并且使用了独特的高级序列化过程，因此速度很快。





### 多持久化方案
例如，社交媒体平台可能使用 MongoDB 这样的文档数据库来存储用户档案和活动提要，使用 Neo4j 这样的图形数据库来分析社交关系，使用 MySQL 这样的关系数据库来管理交易和支付。
通过利用多个数据库，多语言持久性可以帮助提高应用程序的性能、可伸缩性和灵活性。然而，在跨多个系统管理数据一致性、迁移和备份方面，它也带来了额外的复杂性。

在 Java 中，更多的数据库意味着应用程序中更多的依赖关系，这可能会增加 jar-hell 的麻烦。在这种情况下，微服务方法将为您提供帮助，因为您环境中的每个数据库都有自己的接口; 它还有助于将技术与业务隔离开来。

从代码设计的角度来看，有一种端口和适配器模式，或者六角形模型，在这种模式中，您可以将应用程序的核心逻辑与持久层隔离开来。然而，正如前面提到的，更多的层意味着更多的代码，这意味着对可维护性和 bug 的关注。

像在模型-视图-控制器(Model-View-Controller，MVC)体系结构模式中那样，简单地从三个层开始，并将它们隔离开来是一个很好的开始，比如从一个整体开始，而不是从微服务开始。当需求出现的时候，尝试并重构代码。

**识别业务层的抽象，并尽可能避免将其与持久层耦合，这对于一个演进的体系结构来说是至关重要的。**

![[Pasted image 20231123183307.png]]
DDD 区分战略设计和战术设计。战略设计是指软件的整体架构和组织，而战术设计是指单个组件和模块的详细设计。

在战略设计中，DDD 强调定义一个清晰和一致的领域模型的重要性，该模型表示问题领域中的业务概念和流程。这个模型应该独立于任何特定的技术或实现，并且应该基于对领域的深入理解。战略设计还包括定义有界上下文和具体的领域领域，这些领域领域具有与领域的其他部分分开建模的良好定义的边界。

另一方面，战术设计侧重于如何设计和实现各个组件和模块的细节。DDD 使用模式和技术(如聚合、实体、值对象和存储库)在战术设计中对领域对象进行建模和操作。

表示层: DDD 可以通过提供一个清晰和一致的领域模型来影响表示层，该模型可用于指导用户界面和用户交互的设计。表示层应该反映域模型。它应该提供一个用户友好的界面，使用户能够以从领域角度看有意义的方式与应用程序进行交互。

应用程序层: DDD 可以通过提供一组清晰且一致的服务和操作来影响应用程序层，这些服务和操作反映了域中的业务流程和工作流。应用程序层应该被设计成支持领域模型，并且应该提供一个抽象层，这使得领域层能够专注于业务逻辑而不是实现细节。

领域层: DDD 对领域层的影响最大，领域层是应用程序的核心。在领域层，DDD 强调了使用反映业务概念和流程的丰富而富于表现力的语言对领域进行建模的重要性。领域层的设计应该独立于任何特定的技术或实现，并侧重于封装业务逻辑和领域知识。

持久层: DDD 还可以通过提供清晰和一致的方式将域对象映射到数据库来影响持久层。DDD 强调存储库，它在域层和持久层之间提供一个抽象层。存储库使域层能够专注于业务逻辑而不是数据库访问，并提供了一种方法来确保域对象的持久化和检索是一致的和可靠的。




存储库模式是一种设计模式，它在域层和持久层之间提供一个抽象层。存储库模式封装了访问和持久化域对象的逻辑。它提供了一种方法来确保一致和可靠地存储和检索域对象。

通过使用存储库，可以将域层设计为独立于持久层。它可以关注于使用丰富的表达式语言对业务流程和工作流进行建模。存储库模式可以通过使领域层关注业务逻辑和领域知识而不是实现细节(如数据库访问和查询)来显著影响持久层。

存储库模式通常作为域层中的一个接口实现，在持久层中有一个具体的实现。存储库接口定义了一组用于存储、检索和查询域对象的方法。具体的实现使用所选择的持久化技术(比如关系数据库或 NoSQL 数据库)提供了这些方法的实际实现。

存储库模式的一个关键好处是，它使域层与持久层解耦，使应用程序更加模块化，更容易维护。通过分离关注点和封装逻辑，存储库模式可以确保应用程序更加灵活，能够适应不断变化的需求。

存储库模式通常与数据访问对象(Data Access Object，DAO)模式相比较，后者是访问和持久化数据的另一种设计模式。存储库和 DAO 之间的主要区别在于存储库的设计目的是封装用于访问和持久化域对象的逻辑。相反，DAO 被设计用来封装用于访问和持久化数据的通用逻辑。下图显示了从控制器到数据库并返回到控制器的序列。
![[Pasted image 20231123183521.png]]


换句话说，DAO 通常关注底层细节，比如数据库连接、事务和 SQL 语句。相比之下，存储库关注领域模型的更高层关注点

#### JakartaData




我们谈论分布式系统时:
数据集成规模和分布式事务
双写反模式
微服务和共享数据库
**最终一致性问题**


解决这些挑战的一种方法是使用分布式事务协议，如两阶段提交(2PC)或三阶段提交(3PC)。这些协议协调分布式事务中跨多个节点的提交或回滚决策。但是，这些协议有一些局限性，包括延迟增加和协调节点不可用时的故障漏洞
另一种方法是采用较为宽松的内存一致性模型，例如最终一致性或乐观并发控制。这些模型为了提高可伸缩性和可用性，牺牲了严格的一致性保证。当不严格要求实时一致性时，通过允许临时不一致性和异步解决冲突，这些模型可以执行得更好

#### 双写反模式
双写是软件开发中的一种模式或方法，其中数据同时写入两个或多个独立的系统或数据库。双写操作旨在确保服务于不同目的或需要额外数据的多个系统之间的数据一致性和同步性。
虽然双写对于数据集成和同步来说似乎很方便，但是它通常被认为是一种反模式。但是如果一个更新成功而另一个失败会发生什么？以下是双写可能存在问题的几个原因
复杂性和耦合性
性能开销
不一致和失败
数据完整性挑战
可伸缩性限制

让我们探索集成和同步数据的其他选项，而不是仅仅依赖于双写。一些建议的替代办法包括:

ETL: 使用 ETL 流程，可以从源系统中提取数据，将其转换为适当的格式，然后加载到目标系统中。这种方法允许在系统之间实现更大的灵活性和解耦，从而根据需要启用数据转换和映射。

事件驱动架构: 使用事件驱动架构可以帮助异步地在系统之间传播数据更改或事件。它解耦了系统，并允许更灵活和可伸缩的数据集成。事件在发生数据更改时发布，订阅的感兴趣系统可以相应地对这些事件作出反应。

消息队列: 利用消息队列可以提供可靠和可伸缩的数据集成和同步机制。系统可以将消息发布到队列，订阅系统可以按照自己的速度使用它们，从而确保异步通信和解耦通信。

**双写是我们作为分布式架构师所面临的最流行的反模式，它是一个错误。**


#### 共享一个数据库的多个微服务可能会带来一些挑战和缺点
数据耦合和依赖关系
性能瓶颈
缺乏自主性和所有权
数据完整性和一致性
可伸缩性和部署灵活性

**为了克服这些障碍，建议为每个微服务使用一个数据库:**

Saga 设计模式用于长期运行和分布式事务。它允许一系列本地事务(每个都在特定服务的上下文中)参与跨多个服务的协调一致的操作。Saga 模式支持跨服务的通信和维护数据一致性，无需直接访问数据库。

使用 Saga 模式，事务中涉及的每个服务执行其部分，并发出一个事件来指示其任务的完成或进度。对事务感兴趣的其他服务监听这些事件并相应地继续它们的任务。Saga 模式通过依赖事件和协调的本地事务序列来确保数据一致性，而不必直接公开或修改其他服务的数据库。

通过采用事件驱动架构和利用 Saga 模式，微服务可以安全地通信并保持数据的一致性，同时坚持隔离、有限表面积和关注点分离的原则。这种方法增强了安全性，最大限度地减少了直接访问其他服务数据库的相关风险，使微服务生态系统更加健全和安全。

在分布式体系结构中使用几个好的实践可以减少陷阱和挑战的数量，但不能消除它们。在持久性系统之间保持一致性是一个长期的挑战。然而，有一点我们需要理解和接受: 最终一致性。在下一节中，我们将更详细地讨论这个问题。


#### 最终一致性问题
在分布式系统中，最终一致性是一种数据更新不能在所有节点上立即同步的模型。相反，允许临时的不一致性，并逐渐传播更新，直到系统收敛到一致的状态。

在最终一致性中，系统中的不同节点在任何给定的时间点都可能有不同的数据视图。这主要是由于网络延迟、通信延迟和并发更新造成的。然而，最终一致性确保系统达到一致的状态，即所有节点都集中在相同的数据上。

冲突当同时对同一数据进行多次更新时，可能会发生冲突。为了确保一致性，使用冲突解决机制来确定如何解决这些冲突。不同的技术，包括最后写入胜利和应用程序定义的冲突解决策略，可以协调冲突更新。

读修复: 读修复是一种通过在读操作期间更新或同步数据来修复不一致性的技术。当读取操作遇到不一致或过时的数据时，它会触发一个修复过程，从其他节点检索数据的最新版本并更新本地副本，以确保最终一致性。

反熵机制: 反熵机制主动检测和协调分布式系统中的不一致性。这些机制定期比较节点间的数据并启动同步进程以确保一致性。反熵工具的例子包括 Merkle 树、八卦协议和矢量时钟。

Quorum 系统: Quorum 系统确定在分布式系统中实现一致性所需的协议级别。通过定义仲裁和仲裁大小，系统可以确保一定数量的节点必须就更新或操作达成一致，才能被认为是一致的。这有助于防止由于部分更新或失败而导致的不一致。

补偿操作: 在无法自动解决冲突或不一致的更新的情况下，可以使用补偿操作。补偿操作是对不正确或冲突的更新进行反向或付费的操作或过程。这些操作有助于恢复系统中的一致性。

幂等性: 将操作设计为幂等性可以帮助减轻不一致性。在编程和数学中，幂等性是某些运算的一个性质，因此无论执行多少次，都会得到相同的结果。它确保即使由于通信延迟或重试而多次使用某个操作，结果仍然是相同的，从而防止不一致。

**如果你熟悉 NoSQL 数据库，你会记得基本可用的 BASE 意思，其中数据值可能随着时间的推移而变化，但会达到最终一致性**
