[<译> 写给程序猿的范畴论 · 序 - 死循环 - SegmentFault 思否](https://segmentfault.com/a/1190000003882331)

面向对象编程已经难以胜任并发与并行计算领域，它只会造成危险且充满 bug 的设计。数据隐藏，是面向对象的基本前提，一旦对象被共享且被修改，就会造成数据竞争。将数据与互斥锁组合起来看似是个不错的解决方案，但不幸的是，互斥锁不能组合，并且一旦在数据竞争中出现死锁，程序非常难以调试


原则上，有副作用的函数所产生的影响可在函数名以及注释中予以标明。一个叫做 `SetPassword` 或 `WriteFile` 的函数显然在修改某种状态并产生副作用，对此我们已经非常习惯且不以为然。只有当我们开始将这些有副作用的函数层层组装到一起，事情才开始变得棘手。副作用本身并不坏，但是将它们塞到一个大尺度视图中，我们很难再看清它们，它们便脱离了我们的掌控。


B f(A a);
还有一个
C g(B b);
那么这两个函数的复合，就是：
C g_after_f(A a)
{
    return g(f(a));
}


f ∷ A → B
这就是我们的 Haskell 第一课：两个冒号的意思是『类型为……』。一个函数的类型是由两个类型中间插入一个箭头而构成的。要对两个函数进行复合，只需在二者之间插入一个 `.`（或者 Unicode 小圆圈）。
即 g . f


在 Haskell 中，恒等函数是标准库（即 Prelude）中的一部分，其定义如下：

id :: a -> a
id x = x

可能你会问：为何需要这个什么也不做的恒等函数？其实你应该这样问，为什么需要数字 0？


**总结一下：一个范畴由对象与箭头（态射）构成。箭头可以复合，这种复合满足结合律。每个对象都有一个恒等箭头，它是箭头复合的基本单位。**



## 复合是编程的本质

因为问题可以分解为更多的小问题
我们写出求解这些小问题的代码，然后就出现了编程的本质：我么将这些代码片段复合起来，从而产生大问题的解。
一旦小的代码块的实现过程结束，我们就可以忘掉它的实现细节，只关心它与其他代码块的相互影响
面向对象的编程范式的问题在于
如果你想要理解一个对象是如何与其他对象进行复合的时，你需要破开这个对象


范畴
一些对象以及对象之间存在的一些箭头就构成了一个范畴  范畴的本质是复合

态射
把箭头想象为函数，它的学名叫**态射**


复合 复合 复合
## 类型关乎复合

编程中，我们将一个函数的返回结果传递给另一个函数。如果目标函数不能正确的解析源函数传递来的数据 程序就不会工作