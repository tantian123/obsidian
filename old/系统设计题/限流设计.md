
熔断，降级和限流是并列的概念
- 熔断的目的是为了在发现某个服务故障熔断对下游依赖的请求，减少不必要的损耗
- 降级的目的是为了在系统在某个环节故障（比如某个下游故障）不影响整体核心链路，比如返回作者列表，关注服务故障了获取不了关注真实的关注情况，这种情况可以考虑降级关注按钮，全部显示为未关注
- **防止系统过载**



分布式限流和单机限流
限流算法有，**漏桶算法**、**令牌桶算法**和**滑动时间窗口算法**

what how where

计数器：全局counter
不支持时间段内的限流

时间窗口：时间区间内的counter
缺点：在窗口切换的瞬间可能会有请求高峰，可能导致大量请求几乎同时被处理

滑动窗口算法：
滑动窗口算法通过将时间分为多个小的时间段，每个时间段内维护一个独立的计数器。当一个请求到达时，它会被分配到当前时间所在的小时间段，并检查该时间段的计数器是否已达到限制

优点是平滑地处理请求，避免瞬时高峰
缺点是复杂


漏桶算法：
```text
通过一个固定容量的队列来模拟桶，以恒定速率从桶中取出请求进行处理，无论请求到达的频率如何，都保证请求以均匀的速度被处理，超出的请求即溢出
```


典型的生产者-消费者模式  漏桶可能是一个本地的队列，或者是分布式消息队列

基于线程池实现，使用固定容量的阻塞队列和固定数量的处理线程 SynchronousQueue
适用于强制固定速率处理的场景，如网络流量控制、API请求限制

缺点是即使服务器能处理突发的大量请求，还是要排队等待处理

令牌桶：

使用一个线程以固定的频率向桶内加令牌，桶就是令牌数的上限；需要处理请求时，就会从桶中取出一个令牌，没有令牌就会拒绝请求
`Guava`中的`RateLimiter`：
适用于突发情况



单机限流的瓶颈：
机限流有个主要的缺陷就是不够精确，我们可能有1000个实例，但是下游存储只有一套，即多对一的关系，如果单纯的单机以作为衡量指标，很可能把下游打挂

#####
一种是基于Redis做分布式限流，另一种类似于Sentinel分布式限流

Sentinel（森停no）分布式限流是启动一个token server服务器
Redis限流，使用lua脚本保证命令原子性，比如qps设置为10，如果key不存在，就设置key过期时间1s，value=1；如果value小于10，则自增value
缺点是redis可能成为瓶颈



最佳实践：
**多级限流**：可以在应用层、服务层和数据层都设置限流
动态阈值：根据系统的实时负载情况动态调整限流策略
高可用：可以降级为备用方案



不同层次的限流：
应用层限流：通过中间件
代理层限流：使用Nginx或HAProxy等代理服务器


限流设计：
1.阈值  单位时间内允许的请求量
如何确定限流的阈值，常用的就是根据经验设置阈值，然后慢慢调整。
可以进行全链路的压测，关注一些指标例如QPS 数据库连接数 线程数
了解服务间的依赖

2 拒绝策略  常见的拒绝策略包括**直接拒绝**、**快速失败**、**排队等待**等


具体实现：
计数器限流，使用AtomicLong
窗口限流，使用缓存和过期时间
漏桶，类似生产者消费者模型，使用阻塞队列实现
令牌桶，guava（瓜娃）中的RateLimiter

redis lua的分布式限流

相关概念
sentinel：**雪崩问题**：一个服务故障导致依赖于它的服务也出现了故障
例如tomcat连接数被某个异常服务占用
解决方案：
1.超时处理，设置超时时间
2.舱壁模式，就是隔离各个业务能使用的线程数，也就是线程隔离（tomcat里面分离多个线程池，给每个业务分配）
3.熔断降级，由断路器统计业务的异常比例，超出阈值会熔断该业务，拦截所有请求。
4.流量控制，限制业务的qps，避免因为请求激增出现故障（从源头避免故障，限流器属于这种）

流量控制并不能解决网络问题导致的服务故障雪崩，所以还是需要前三种方式

服务保护框架
sentinel 基于信号量隔离，统计当前业务的线程并限制。
熔断降级策略是 基于慢调用的比例
可以基于QPS进行限流或者调用关系的限流
支持流量整形，支持慢启动，有控制台


整合sentinel
引入依赖 配置控制台 访问微服务endpoint触发sentinel监控

簇点链路：
默认情况下，sentinel会监控springmvc的每一个endpoint（controller service mapper）
