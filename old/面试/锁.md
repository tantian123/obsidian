锁分类

## 乐观 悲观
概念：乐观 认为操作不会引发并发问题 不上锁 但是在修改前会判断数据有没有被其他线程修改，从而取消当前操作
悲观 每次取数据时都认为其他线程会修改 所以都加锁  由于阻塞原因，所以导致吞吐量不高

乐观实现方式：乐观锁的version版本号和CAS机制（concurrent包中的实现）
悲观锁的Synchronized和Lock

version版本号：
``` sql
UPDATE your_table SET column1 = 'new_value', version = version + 1 WHERE id = your_id AND version = your_current_version;
```

CAS机制：
之前要获取的A值 经过处理得到的B值 目前内存所在位置的C值
会将A值与C值比较，相同则代表值没有变化，即可将B值替换到C值的位置
这一操作的原子性是通过CPU的原子操作来保证的。

CAS缺点和具体实现看具体的文章


悲观实现方式 
- `MySQL`的读锁、写锁、行锁等
- `Java`的`synchronized`关键字


select...for update
**for update 仅适用于InnoDB，并且必须开启事务，在begin与commit之间才生效。**
for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。
```
悲观是 先select for update 再执行修改操作
begin;
select * from goods where id = 1 for update;
update goods set stock = stock - 1 where id = 1;
commit;

乐观是
之前的版本号机制
```

应用场景 
读多写少 乐观锁
读少写多 悲观锁

## mysql行锁 表锁 间隙锁
**InnoDB默认是行级别的锁，当有明确指定的主键时候，是行级锁。否则是表级别。**
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
当索引失效的时候，行锁会升级成表锁

- 什么是间隙锁（对于键值在条件范围内并不存在的记录，叫做间隙）
当我们采用范围条件查询数据时，InnoDB 会对这个范围内的数据进行加锁。比如有 id 为：1、3、5、7 的 4 条数据，我们查找 1-7 范围的数据。那么 1-7 都会被加上锁。2、4、6 也在 1-7 的范围中，但是不存在这些数据记录，这些 2、4、6 就被称为间隙

间隙锁的缺点
范围查找时，会把整个范围的数据全部锁定住，即便这个范围内不存在的一些数据，也会被无辜的锁定住，比如我要在 1、3、5、7 中插入 2，这个时候 1-7 都被锁定住了，根本无法插入 2。在某些场景下会对性能产生很大的影响


所以：
尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
尽可能减少索引条件，避免间隙锁
## 互斥 读写
- 互斥锁在Java中的具体实现就是ReentrantLock
    
- 读写锁在Java中的具体实现就是ReadWriteLock

## 公平 非公平
- 公平锁是指多个线程按照申请锁的顺序来获取锁。
    
- 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
## 可重入

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。
``` java
// 如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

synchronized void setA() throws Exception{  
    Thread.sleep(1000);  
    setB();  
}  
  
synchronized void setB() throws Exception{  
    Thread.sleep(1000);  
}
```
ReentrantLock和Synchronized都是可重入锁
## 分段
分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，**ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；****同时又是一个ReentrantLock（Segment继承了ReentrantLock)。**

当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

## 独享 共享
- 独享锁是指该锁一次只能被一个线程所持有。
    
- 共享锁是指该锁可被多个线程所持有。

ReentrantLock而言，其是独享锁
对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。

对于Synchronized而言，当然是独享锁
## 自旋

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

典型的自旋锁实现的例子，可以参考自旋锁的实现

## 偏向 轻量级 重量级
这三种锁是指锁的状态，并且是针对Synchronized。
在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段MarkWord来表明的。

- 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    
- 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    
- 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。