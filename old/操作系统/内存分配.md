内存分配是，程序在运行时，从操作系统获取可分配的内存，用来存储程序运行需要的数据和运行时的中间结果。在不同的操作系统和编程语言中都不同。
#### 静态内存分配
静态内存分配发生在编译时期，程序员在程序的数据段或者堆栈段预先分配好内存空间，
例如数据和全局变量
### 动态内存分配 又称为堆内存分配
在程序运行时发生，通过系统调用(malloc 或者new) 来申请或者释放内存
会出现内存泄漏的问题
### 栈式内存分配
在函数调用过程中使用的一种内存分配方式。
原理是在函数被调用时，在当前栈帧中分配函数的局部变量和参数。当函数调用结束时，栈帧被弹出，局部变量和参数被自动释放。这种方式具有快速分配和释放内存的优点，但是栈空间有限，无法进行动态扩展。


## 内存
代码段 需要执行的代码 编译时确定，大小是固定的

数据段 存放初始化的全局变量和静态变量  编译时确定，大小是固定的

BSS段 未初始化的全局变量和静态变量的区域  编译时可以确定，程序执行时变化

栈 存放函数调用时局部变量和函数参数的区域 栈的大小是在编译时无法确定的，它会根据程序运行时的需要动态地增长或缩小 
在函数被调用时，栈帧被创建，用于存储局部变量和函数参数。在函数调用结束时，栈帧被弹出，局部变量和函数参数也被销毁

堆 堆是存放程序运行时动态分配内存的区域，它的大小是动态变化的。堆的大小取决于程序运行时需要动态分配的内存大小

## 进程切换中的内存操作
保存当前进程的执行状态（包括程序计数器、寄存器、程序状态字和用户栈等），切换内核栈，然后恢复下一个进程的执行状态（）

## 进程用户栈和进程内核栈
内核在创建进程的时候，在创建task_struct的同时，会为进程创建两个栈，第一个栈也就是进程用户栈，存在于用户空间使用，另外还有一个内核栈，存放在内核空间。**内核栈存在的意义：如系统调用在陷入内核后，系统调用中也是存在函数调用和自动变量，这些都需要栈支持**

## 进程和线程和协程的内存分配
进程拥有自己独立的地址空间，包括代码段、数据段、堆和栈等，这些空间是由操作系统在进程创建时分配的。不同的进程之间的地址空间是相互独立的，彼此不会相互干扰。

线程和协程都共享所属进程的地址空间，线程的栈空间通常也是在进程的地址空间中分配的。协程则更加轻量级，它们在同一个线程内部共享相同的栈空间，不需要额外的内存分配。

## 协程的区别
进程和线程的调度是由操作系统负责的，而协程则是由执行单元相互协商进行调度的，所以它的切换发生在用户态。
## stackful协程和stackless协程
核心区别是一个是采用类似生成器（generator）的思路实现了上下文切换，一个切换栈帧。

stackful是指每个coroutine有独立的运行栈，比如每个goroutine会分配一个4k的内存来做为运行栈，切换goroutine的时候运行栈也会切换。stackful的好处在于这种coroutine是完整的，coroutine可以嵌套、循环。
stackless coroutine，比如generator continuation，这类coroutine不需要分配单独的栈空间，coroutine状态保存在闭包里

1.  JavaScript和Python中的Generator机制
在JavaScript和Python中，协程的实现方式主要是基于Generator机制。Generator是一种可以暂停执行的函数，它可以返回一个中间状态，并在下一次调用时继续执行，从而实现协程的切换。
通过Generator机制，JavaScript和Python可以方便地实现协程的创建和管理，可以实现异步编程和协程的组合等功能。例如，在JavaScript中，可以使用async/await语法来简化协程的使用，而在Python中，可以使用asyncio库来实现协程的并发和异步编程。

2.  Lua和Go中的Stackful协程实现
在Lua和Go等编程语言中，协程的实现方式主要是基于Stackful协程的实现方式。在Lua中，可以使用coroutine库来创建和管理协程，通过yield和resume等函数来实现协程之间的切换。而在Go中，可以使用goroutine来创建和管理协程，通过channel等机制来实现协程之间的通信和同步。