SOLID、KISS、YAGNI、DRY、LOD

SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母

单一职责原则（SRP）
**一个类或者模块只负责完成一个职责（或者功能）**

不要设计大而全的类，要设计粒度小、功能单一的类
举一个例子，一个类里既包含订单的一些操作，又包含用户的一些操作。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。

判断原则：
1.类中的代码行数、函数或属性过多
2.类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想
3.类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来
4.比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰


开闭原则 Open Closed Principle
怎么才算满足或违反‘开闭原则

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等几种粒度），而非修改已有代码（修改模块、类、方法等）。

**其实就是提高代码的可扩展性**


给类添加属性不违反开闭原则，它的粒度是属性。
修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则

例子：代码中通过 Kafka 来发送异步消息，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。