[GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)

**MVC 的核心目的：分离关注点**
优点：
- 代码的分离使得开发和维护更加方便。
缺点：
- 控制器可能变得复杂，尤其是在大型系统中。

MVVM 通常用于数据绑定框架 保证view的无状态
优点：
- 强大的数据绑定能力可以显著减少样板代码。
- 提高了开发效率。
缺点：
- 数据绑定的实现可能会增加复杂性。
MVVM利用数据绑定彻底完成了从命令式编程到声明式编程的转化，使得View逐步无状态化

在传统 GUI 框架中，多视图共享一个模型（如 MFC 的 Document/View 架构）时，模型需要通过通知机制（如观察者模式）主动告知视图刷新
视图（View）和控制器（Controller）分离的目的较弱 ，传统 GUI 中经常将两者合并，因为控制器通常为视图服务，且多为一一对应关系



在 Web 场景下，每次请求通常只生成一个视图（View）。视图的展现发生在客户端，而视图的创建和渲染在服务端完成 
- 由于这个特点，Web 中通常不需要模型主动通知视图更新。
- 视图（View）在被创建时即可从模型（Model）中读取数据
Web 中的视图依赖模型，但不是通过模型通知视图来实现更新，而是控制器（Controller）从模型获取数据并填充到视图中
MVC 的实现并不依赖观察者模式。
- 传统 GUI 使用观察者模式，是为了在多视图场景下实现模型变更后各视图的同步更新。
- 在 Web 中，由于视图生成时直接读取模型，观察者模式的必要性大大降低




前端框架演变
静态html加动态script
MVC
MVP和MVVM

关注点分离 实现了业务数据 (模型) 与用户界面 (视图) 的隔离，第三个组件 (控制器)(传统上) 管理逻辑、用户输入并协调模型和视图
Domain 元素被称为 Model，它不知道用户界面 (视图和控制器)

表示由视图和控制器负责，但是并不只有一个视图和控制器。屏幕上显示的每个元素都需要一个 View-Controller 对，因此它们之间没有真正的分离

Controller 在这一对中的角色是处理用户输入 (比如按键和单击事件)
每当模型发生变化时，视图都会依赖观察者模式来更新

当一个模型发生变化时 (例如当它被更新时) ，它通常会通知它的观察者 (例如视图，我们将很快介绍的一个概念) 一个变化已经发生，以便他们可以做出相应的反应。
此外，一个模型还可能有多个观察它的视图。

总的来说，模型主要关注业务数据
在 JavaScript 应用程序中，“状态” 有不同的含义，通常指的是当前组件的 “状态”

在传统的 Web 开发中，在独立视图之间导航需要使用页面刷新。然而，在单页 JavaScript 应用程序中，一旦通过 Ajax 从服务器获取数据，就可以在同一页内的新视图中动态地呈现数据，而不需要进行任何此类刷新。因此，导航的作用落到了 “路由器” 上，它协助管理应用程序状态 (例如，允许用户将导航到的特定视图标记为书签)。然而，由于路由器既不是 MVC 的一部分，也不存在于任何类似 MVC 的框架中，因此我不会在本节中对它们进行更详细的介绍（导航不是mvc的一部分）
控制器是模型和视图之间的中介，它们通常负责两个任务： 当模型更改时更新视图，当用户操作视图时更新模型

将展示从业务逻辑中解耦出来。通过事件驱动
数据绑定 是很好的实现同步的方式
领域元素被称为模型。模型对象完全不了解 UI
MVC 的表示部分由剩下的两个元素组成： 视图和控制器。控制器的工作是获取用户的输入并找出如何处理它。
不只有一个视图和控制器，对于屏幕的每个元素、每个控件和整个屏幕，都有一个视图 - 控制器对

流同步和观察者同步。这两种模式描述了处理触发屏幕状态和会话状态之间的同步的可选方法。窗体和控件通过应用程序的流来操作需要直接更新的各种控件。MVC 通过对模型进行更新，然后依靠观察者关系来更新观察该模型的视图



关于 MVC 的摘要了。

在表示 (视图和控制器) 和领域 (模型) 之间进行有力的分离 —— 分离的表示。

将 GUI 小部件划分为控制器 (用于响应用户刺激) 和视图 (用于显示模型的状态)。控制器和视图 (大多数情况下) 不应该直接通信，而应该通过模型进行通信。

让视图 (和控制器) 观察模型，以允许多个小部件进行更新，而不需要直接通信 - 观察者同步。

MVC
界面被分到了View，数据分到了载体Model上由Model“携带”，业务集中在Controller中，而推动业务的事件由用户与View交互，通过View向Controller发动。

**切断的View和Model的联系，让View只和Presenter（或是Controller）交互**
MVP模式




MVVM模式 **优化了数据频繁更新的解决方案**
**用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步**
数据绑定你可以认为是Observer模式或者是Publish/Subscribe模式


当场景变到Web的时候，我们发现**MVVM用来做服务端是极其不适用的**
直接刷新页面的原因是因为这样更直接，更容易解决数据更新的问题
很多时候**你不会愿意为了一个数据更新写一个AJAX，更别说这个AJAX要带来Loading、事件顺序处理、网络问题、异常处理等等，这就是开发成本过高**

**在本地软件，更新数据是一个引用问题，而在网络应用上，这是一个传输问题**。传输成本远高于引用成本，引用之上顶多是在本地内存中再进行一次内存拷贝

这个时候，**我们会更倾向于用MVC模式，因为在Web层面，我们更倾向于一次性更新数据**



Facebook强调，双向数据绑定极不利于代码的扩展与维护。从具体的代码实现角度来看，[双向数据绑定](https://zhida.zhihu.com/search?content_id=2906970&content_type=Article&match_order=4&q=%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A&zhida_source=entity)会导致更改的不可预期性(UnPredictable)，就好像Angular利用Dirty Checking来进行是否需要重新渲染的检测，这导致了应用的缓慢，简直就是来砸场子的。而在采用了单向数据流之后，整个应用状态会变得可预测(Predictable)，也能很好地了解当状态发生变化时到底会有多少的组件发生变化。另一方面，相对集中地状态管理，也有助于你不同的组件之间进行信息交互或者状态共享，特别是像Redux这种强调Single Store与SIngle State Tree的状态管理模式，能够保证以统一的方式对于应用的状态进行修改，并且Immutable的概念引入使得状态变得可回溯

## Flux:数据流驱动的页面
Flux主要由以下几个部分构成：
- Stores:存放业务数据和应用状态，一个Flux中可能存在多个Stores
- View:层次化组合的React组件
- Actions:用户输入之后触发View发出的事件
- Dispatcher:负责分发Actions
Redux:集中式的状态管理

Redux是Flux的所有变种中最为出色的一个，并且也是当前Web领域主流的状态管理工具，其独创的理念与功能深刻影响了GUI应用程序架构中的状态管理的思想。Redux将Flux中单例的Dispatcher替换为了单例的Store，即也是其最大的特性，集中式的状态管理。并且Store的定义也不是从零开始单独定义，而是基于多个Reducer的组合，可以把Reducer看做Store Factory。