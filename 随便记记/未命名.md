协程
可暂停 可恢复执行 可销毁的函数（除了函数原有的功能：调用和返回之外）

用来干嘛 
io请求的不确定性，什么时候有请求，有多少请求，需要等多久才有数据 都不确定
线程消耗太大，线程切换的开销，线程并发的问题->
解法有：
事件驱动框架（异步框架 但是是同步IO）/ actor /csp
解决了性能和并发问题，问题在于写代码很麻烦
->协程解决了代码编码复杂度的问题和C10K问题（
协程并没有解决io密集问题，协程只是优化了异步回调模型增强了代码的可读性。
真正解决io密集问题的是以**io多路复用函数**以及**非阻塞套接字**为基础构建的基于事件的响应编程模式
）

事件驱动框架通过IO多路复用来提高性能
Nginx和Node Js就是这种模型



就是一个控制程序，在等待时会自动让出时间片，这就是协程的思想

协程和用户态线程的区别  
都是在用户空间实现的 asyncio是协程  goroutine是go程
协程是**程序控制**的 
用户态由**库函数控制**的，无法手动管理

进程 线程 协程
都是程序运行的上下文


程序就是状态机
为了解决进程通信开销大的问题，就有了线程（本质区别还是隔离级别）
由自己管理切换的是用户态线程
由操作系统管理切换的是内核态线程
一种是协作式的 一种是抢占式的
协作式的问题在于如果程序有问题例如while(true) 会一直死循环
所以操作系统不能使用这种方式调度，必须是抢占式的


操作系统的调度是简单粗暴的，通过时间片/优先级等概念，而且每次切换都需要保留完整的上下文，
在线程互相独立且不会阻塞的情况下，抢断式的调度是不错的选择
**但是线程不是互相独立的，经常因为争抢而阻塞，这时抢占式的线程调度器是没有意义的，**
主动让出时间片才是更加适合的模式
如果请求都是io密集阻塞的，因为线程是抢占式的，这样线程就会频繁的线程上下文切换，
这样无意义的上下文切换开销太大

阻塞 I/O 操作：传统的 I/O 操作（如文件读写、网络请求等）通常是阻塞的，这意味着当线程发起 I/O 请求时，它会一直等待 I/O 操作完成，期间不会执行任何其他任务。这不仅浪费了 CPU 资源，还限制了系统的并发能力。


在早期的单任务计算机中，用户一次只能提交一个作业，独享系统的全部资源，同时也只能执行单一任务。计算时不能并发进行 I/O 读写，而 CPU 与 I/O 的速度存在巨大差异——CPU 执行指令的速度远快于 I/O 操作。因此，一个作业在 CPU 上所花费的时间非常少，大部分时间都在等待 I/O 完成。 为更合理地利用 CPU 资源，操作系统引入了多进程的概念，将内存划分为多个独立的块，每个程序使用各自的内存空间互不干扰。这使得 CPU 可以在多个进程之间切换执行，提高了 CPU 的利用率。每次进程切换时，操作系统需要保存当前进程的上下文（如程序计数器、栈、内核数据结构等），以便下次恢复执行。Linux 采用了基于时间片和优先级的完全公平调度算法来管理这些进程。

尽管多进程提高了 CPU 的利用率，但进程之间的上下文切换开销较大。为了减少这种开销，操作系统引入了线程。线程是进程内的轻量级实体，同一进程中的所有线程共享该进程的内存空间和其他资源。这样，在线程之间切换时，不需要转换内存地址空间，从而减少了上下文切换的成本。Linux 实现中，虚拟地址空间转换到物理地址空间需要查页表，这是一个相对缓慢的过程。为此，Linux 使用 TLB (Translation Lookaside Buffer) 来缓存页表项。然而，当进程切换后，TLB 会失效，导致性能下降。因此，线程切换比进程切换更快。

对于 IO 密集型应用（如 Web 服务器、网关等），追求高吞吐量有两种常见思路： 为每个请求创建一个线程：可以使用线程池技术降低线程创建的开销，但随着线程池增大，CPU 切换开销也会增加。此外，线程占用大量内存（MB 级别），数量受限。 异步非阻塞开发模型：通过 I/O 多路复用（如 epoll）让进程或线程不阻塞，省去上下文切换的开销。这种方法性能非常好，但实现复杂。 协程提供了一种介于这两者之间的解决方案，既简单又高效。协程是用户态的一种抽象，操作系统并不直接管理它们。其主要思想是在用户态实现调度算法，用少量线程完成大量任务的调度。协程解决了以下问题： 内存占用小，创建开销低：协程只是一个简单的数据结构，无需系统调用，且设计得非常紧凑，通常只有 KB 级别的内存占用。 减少上下文切换开销：通过减少可执行线程的数量，降低上下文切换次数。协程可以在同一个线程内协作运行，只有在必要时才会暂停或恢复，从而减少了整体的切换成本。


从进程到线程再到协程，每一步都是为了更好地利用 CPU 资源，提高系统的并发性和响应速度。从单进程到多进程提高了 CPU 利用率；进程提供了独立的内存空间和资源隔离，但上下文切换开销大；线程减少了上下文切换的开销，但在高并发场景下仍然存在瓶颈；协程则进一步降低了开销，通过用户态调度实现了高效的并发处理，特别适合 IO 密集型应用


汇编语言确实没有直接对应于进程、线程或协程这些高级抽象的概念。在汇编语言中，程序控制流的管理主要通过条件跳转（jump）、无条件跳转（jmp）、调用子程序（call）和返回（ret）等指令来实现。这些低级指令构成了所有高级并发和并行机制的基础

但是协程还是依赖于线程的，
操作系统的CPU调度是以线程为单位的，操作系统负责把线程分配到各个CPU核心上
我们的目的还是重分利用多核，同时避免上下文切换
在线程数不多，以CPU计算为主的情况，协程的优势也就不明显；但如果待执行的任务里存在大量等待（例如IO任务必然伴随大量等待），对比系统线程，协程将具备特别明显的优势

协程栈2kB 进程一般几M





在协程中调用阻塞式i/o会阻塞整个线程，因为协程之间的调度是用户在协程中主动调用协程切换功能（比如yield语句）手动实现的，而不是系统自动强制执行的，如果一个协程调用了阻塞式i/o，这个协程就被阻塞了

所以还是回到之前那句话
协程并没有解决io密集问题，协程只是优化了异步回调模型增强了代码的可读性。
真正解决io密集问题的是以**io多路复用函数**以及**非阻塞套接字**为基础构建的基于事件的响应编程模式


协程解决网络IO堵塞一般
 通过操作系统的select或epoll模块 建立连接前挂起协程

=》结合实际场景：之前多个连接