Java15默认关闭了偏向锁
在并发越来越高的情况下，偏向锁在过多的争抢下反而会影响效率并且很快就会发生膨胀

原理Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态

由于性能差，才引入了锁升级


原理
使用监视器锁来实现对临界区的控制
使用内存屏障保证了内存可见性和避免了指令重排


如何使用
修饰方法（也是将当前方法所属的对象作为锁）或者将对象作为锁


锁升级：无锁 -> 偏向锁 -> 轻量级锁-> 重量级锁
why：避免使用操作系统层面的锁，开销太大，需要上下文切换

当第一个线程获取该锁时，会从无锁升级为偏向锁，修改markword 并记录线程id，
后续该线程的访问都不需要获取锁
当第二个不同线程获取该锁时，判断markword中的线程id是不是自己，如果不是就通过CAS操作获取锁，成功就替换线程id，失败则升级为轻量级，该线程竞争失败会阻塞，默认开启自旋一段时间，
如果自旋等待失败，锁会再次升级，此时重量级锁，
锁的获取和释放是基于操作系统级别的




在JDK 1.6 ，官方引入了如下的一系列优化
锁消除  
JIT 编译器在动态编译同步块时，会使用`逃逸分析`技术，判断同步块的锁对象是否只能被一个对象访问，没有发布到其它线程
锁粗化
JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这`几个同步块合并为一个大的同步块`，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。




任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。
![[Pasted image 20241216204759.png]]

blased lock标识识别是偏向锁



