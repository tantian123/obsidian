在2PC中，协调者（或至少其替代者）必须在整个提交过程中存活，这大大降低了可用性。3PC在某些情况下放宽了这一要求，但在网络分区的情况下容易出现脑裂问题。
共识算法比原子提交算法更为复杂，但具有更好的容错特性




网络是不可靠的：消息可能会**丢失、延迟或顺序错乱**

消息确认：引入确认，一种让接收者通知发送者它已收到消息的方法
我们需要使用双向通信通道，并添加一些手段来区分消息的不同之处；例如，序列号，这是唯一的单调递增的消息标识符。

引入消息重传，因为 添加确认 还不足以称之为可靠的通信协议，发送的消息仍可能丢失，或者在确认前失败

重传的问题：我们不知道它是否已经被处理、即将处理、丢失了还是远程进程在接收到消息之前崩溃——这些状态中的任何一个都是可能的。我们可以重试操作并再次发送消息，但这可能导致消息重复。处理重复消息只有在我们要执行的操作是**幂等的情况下才是安全的**

不可靠的网络给我们带来了两个问题：消息可能按错误的顺序到达，并且由于重传，某些消息可能会到达多次。我们已经引入了**序列号**

分布式系统中只有两个难题：1. 消息的保证顺序 2. 精确一次传递

大多数实际系统采用至少一次传递
另一种传递语义是至多一次传递




FLP 不可能性：FLP不可能性结果所示，**在异步系统中，没有任何协议可以保证达成共识**

我们可以放宽这些假设，认为系统是同步的。为此，我们引入了时间的概念。在同步模型下考虑系统要容易得多
在同步模型下设计系统允许我们使用超时机制。我们可以在其基础上构建更复杂的抽象，如领导者选举、共识、故障检测等。这使得最理想的情况更加健壮，但如果时间假设不成立，则会导致失败

同步性是分布式系统的一项基本属性：它影响性能、可扩展性和总体可解性




故障检测算法
许多分布式系统通过使用心跳机制实现故障检测。这种方法非常流行，因为它简单且具有强完整性。这里讨论的算法假设不存在拜占庭故障：进程不会试图故意歪曲自己的状态或邻居的状态。

两种周期性过程之一来查询远程进程的状态：
- **Ping**：发送消息给远程进程，检查它们是否仍然存活，方法是在指定时间内期待响应。
- **Heartbeat**：当进程主动通知其对等方它仍在运行时触发，方法是向它们发送消息。

外包心跳：让多个邻居对目标发起心跳



### 领导者选举
为了减少同步开销以及达成决策所需的消息往返次数，一些算法依赖于领导者（有时称为协调者）进程的存在，负责执行或协调分布式算法的步骤。

所有算法都容易出现脑裂问题：我们可能会在独立子网中结束有两个不知道彼此存在的领导者。为了避免脑裂，我们需要获得集群范围内的多数票

许多共识算法，包括Multi-Paxos和Raft，依赖于领导者来进行协调。但是，领导者选举与共识是一样的吗？要选举一位领导者，我们需要对其身份达成共识。**如果我们能对领导者的身份达成共识，我们可以用同样的方式对任何事情达成共识**

依赖于领导者选举的算法通常允许存在多个领导者，并尽可能快地解决领导者之间的冲突。例如，在Multi-Paxos（参见“多Paxos”）中，两个冲突的领导者（提议者）中只有一个可以继续，这些冲突通过收集第二个法定人数来解决，确保来自两个不同提议者的值不会被接受。

在Raft（参见“Raft”）中，领导者可能会发现其任期已经过期，这意味着系统中存在不同的领导者，并更新其任期至最近的一个。



###  一致性模型
一致性模型非常重要，因为它们解释了在存在多个数据副本的情况下系统的可见性语义和行为
、
几种强一致性模型，如线性化和序列化，以及一种弱一致性形式：最终一致性
#### 容错性

#### 数据复制

#### 臭名昭著的CAP定理
在一个异步系统中，，我们不能构建一个在出现网络分区时同时保证可用性和一致性的系统
- 一致性和分区容忍度（CP系统）：优先拒绝请求而不是提供可能不一致的数据。
- 可用性和分区容忍度（AP系统）：放宽一致性要求，并允许在请求期间提供可能不一致的值。



#### 严格一致性（Strict Consistency）
任何进程的任何写入操作都会立即对随后的任何进程的读取操作可用。它涉及到全局时钟的概念
这只是理论模型，实际上无法实现，因为物理定律和分布式系统的工作方式

#### 线性化（Linearizability）
**成本太高**
线性化是最强的单对象、单操作一致性模型。在此模型下，写入的效果将在其开始和结束之间某个时间点对所有读取者恰好可见一次，并且没有任何客户端能够观察到部分（即未完成的、仍在传输中的）或不完整的（即在完成前中断的）写入操作的状态转换或副作用

线性化的一个最重要特性是可见性：一旦操作完成，所有人都必须看到它

#### 实现线性化的成本
许多系统今天都避免实现线性化。即使是CPU，默认情况下在访问主内存时也不提供线性化。这是因为同步指令代价高昂、速度慢，并涉及跨节点的CPU通信和缓存失效

大多数现代编程语言提供了原子原语，允许原子写入和比较并交换（CAS）操作
但是可能存在ABA问题

#### 顺序一致性
实现线性化可能过于昂贵，但可以在保持相当强的一致性保证的同时放松模型。顺序一致性允许按照某些顺序排列操作，就好像它们是以某种顺序执行的，同时要求每个单独进程的操作按照进程执行的相同顺序执行。

顺序一致性最初是在并发性的背景下提出的
最初的描述要求对同一单元的内存请求在队列中有序（FIFO，到达顺序），不对独立内存单元上的重叠写入施加全局排序，并允许读取从内存单元或队列中获取最新值


顺序一致性经常与线性化混淆，因为两者有相似的语义。顺序一致性，如同线性化一样，要求操作全局有序，但线性化要求每个进程的本地顺序和全局**顺序一致**，
重点在于顺序一致


类似于线性化，**现代CPU默认不保证顺序一致性**，因为处理器可以重新排序指令，我们应该使用内存屏障（也称为围栏）来确保写入按顺序对并发运行的线程可


#### 因果一致性
在因果一致性模型下，所有进程必须以相同的顺序看到因果相关的操作。没有因果关系的并发写入可以由不同的处理器以不同的顺序观察到

你可以将此理解为在线论坛上的交流：你在网上发布了一些内容，有人看到了你的帖子并回复了它，第三人看到了这个回复并继续了对话线程。对话线程可能会分叉：你可以选择回复其中一个对话并继续事件链，但有些线程可能只有几个共同的消息，因此对于所有消息来说，可能没有单一的历史记录。

#### 最终一致性
在最终一致性下，更新异步地通过系统传播
**最终一致的系统有时用CAP术语来描述：你可以用可用性换取一致性**




### 分布式事务
单分区事务涉及到悲观（基于锁或跟踪的）或乐观（尝试和验证）并发控制方案，
但这两种方法都不能解决多分区事务的问题，后者需要不同服务器之间的协调、分布式提交和回滚协议
为了让多个操作看起来是原子的，尤其是当其中一些是远程操作时，我们需要使用一类称为**原子提交**的算法

两种原子提交算法：两阶段提交，它解决了提交问题，但不允许协调者进程失败；和三阶段提交,它解决了非阻塞原子提交问题，并允许参与者在协调者失败的情况下继续

两阶段提交（Two-Phase Commit, 2PC）是分布式提交中最直接的协议
2PC通常在数据库事务的背景下讨论。2PC分两个阶段执行。在第一阶段，决定的值被分发，并收集投票。在第二阶段，节点只是切换状态，使第一阶段的结果变得可见
2PC假定存在一个领导者（或协调者），它保存状态，收集投票，并作为同意轮次的主要参考点。其余的节点被称为参与方

####  2PC中的参与方故障
如果一个参与方在提议阶段失败，协调者不能继续进行提交，因为它需要所有投票都是有效的
如果一个参与方不可用，协调者将中止事务


#### 2PC中的协调者故障
如果一个参与方在第二阶段没有从协调者那里收到提交或中止命令,它应尝试找出协调者做出了哪个决定
在这种情况下，可以从对等体的事务日志或备份协调者处复制决策信息。复制提交决策是安全的，因为它是统一的：2PC的核心就是所有站点要么全部提交，要么全部中止，一个参与方的提交意味着所有其他参与方也必须提交

协调者无法继续进行提交或中止会使集群处于未决定的状态。这意味着在协调者永久故障的情况下，参与方将无法了解最终决定。由于这一特性，我们说2PC是一种阻塞型原子提交算法

许多数据库使用2PC：MySQL、PostgreSQL、MongoDB等。两阶段提交经常被用来实现分布式事务，因为它的简单性（易于理解、实现和调试）和低开销（协议的消息复杂性和往返次数较少）。重要的是要实现适当的恢复机制，并拥有备份协调者节点，以减少上述故障的可能性


三阶段提交（Three-Phase Commit, 3PC）协议通过添加一个额外的步骤和双方的超时机制，使得原子提交协议能够抵御协调者故障，并避免未决定状态

三阶段提交轮次由三个步骤组成：
1. **提议（Propose）**：
    - 协调者发出提议值并收集投票。
2. **准备（Prepare）**：
    - 协调者通知参与方关于投票结果。如果投票通过并且所有参与方都决定提交，协调者发送Prepare消息，指示它们准备提交。否则，发送Abort消息，本轮结束。
3. **提交（Commit）**：
    - 协调者通知参与方提交事务。


3PC在提交/中止步骤之前增加了一个准备（Prepare）阶段，在提议（Propose）阶段，协调者收集了参与方的状态信息，并在这一阶段进行沟通，即使协调者失败，协议也可以继续
超时机制。根据当前执行的是哪个步骤，超时后会强制做出提交或中止的决定
####  3PC中的协调者故障
对于3PC来说，最坏的情况是网络分区
网络分区发生在准备阶段后时，有些则无法与协调者通信，并将在超时后中止。这导致了“脑裂”现象：一些节点继续提交，而另一些则中止

虽然理论上3PC在一定程度上解决了2PC的阻塞问题，但它具有更大的消息开销，引入了潜在的矛盾，并在网络分区存在的情况下表现不佳。这可能是3PC在实践中不被广泛使用的主要原因

#### Spanner和Calvin

### 数据库分区

在讨论Spanner和Calvin时，我们频繁使用了“分区”这个术语。现在让我们更详细地探讨一下它。由于将所有数据库记录存储在一个节点上对于大多数现代应用程序来说是不切实际的，许多数据库采用分区：即将数据逻辑上划分为更小、更易管理的片段。

##### 如何分区
最直接的分区方法是将数据分割成范围，并允许副本集仅管理特定的范围（分区）。在执行查询时，客户端（或查询协调器）必须根据路由键将请求路由到正确的副本集，以进行读取和写入。这种分区方案通常被称为分片（sharding）：每个副本集作为一组数据的单一来源。

#### 分区算法
哈希函数 
一致性哈希


快照隔离（Snapshot Isolation, SI）的事务模型。
#### 快照隔离
快照隔离保证了事务内进行的所有读取都与数据库的一个快照一致。该快照包含在事务开始时间戳之前提交的所有值。如果有写-写冲突（即，当两个并发运行的事务尝试对同一单元格进行写入
时），只有其中一个会提交。这一特性通常被称为“先提交者获胜”。

快照隔离防止了读倾斜（read skew），这是一种在读已提交（read-committed）隔离级别下被允许的异常。例如，x和y的总和应该是100。事务T1执行操作`read(x)`并读取值70。T2更新两个值`write(x, 50)`和`write(y, 50)`，然后提交。如果T1尝试运行`read(y)`，并基于由T2新提交的y值（50）继续事务执行，这将导致不一致性。T1读取的x值是在T2提交前的，而新的y值并不与此x值相一致。由于快照隔离只使特定时间戳之前的值对事务可见，T1不会看到新的y值50




