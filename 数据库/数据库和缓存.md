缓存一致性

适用于缓存的场景：
适合读多写少的场景，例如昨日的排名或者是商品信息

在解决缓存一致性的问题时，要根据不同的业务场景，使用不同的更新策略
cache-aside
read through  直读
write through 直写
write back 写回   也称Write Behind延迟写入

在读多写少的场景下，可以选择cache-aside结合数据库日志做补偿的方案

特点：适合读多写少
当读操作远远多于写操作时，这种模式能显著减少对数据库的访问次数，提高读取性能
但是存在缓存失效相关的问题，所以需要数据库日志做补偿

在写多的场景下，可以使用write through结合分布式锁
特点：  **强一致性**
在写多的场景中，通常会结合使用分布式锁来防止多个客户端同时修改相同的数据，从而避免数据竞争和冲突

写超级多的场景下，可以使用write back，
特点：异步写操作极大的降低了请求延迟并减轻了数据库的负担。同时也放大了数据不一致的
类似日志先行的策略，异步合并操作，减少写次数
在写操作极其频繁的场景下，write-back可以大幅减少对持久化存储的压力，因为不是每次写操作都立刻触发对数据库的写入，而是合并多次写操作成一次写入，提高了写性能


**cache-aside**：读 先读缓存，如果命中，返回数据；如果没有，再读数据库并写入缓存中
写 先写入数据库  然后删除缓存
```
func find(key){
	data=cache.get(key)
	if(data==null){
		data=db.get(key)
		cache.set(key,data)
	}
	
}
func set(key,value){
	boolean res=db.set(key,value)
	if(res){
		cache.remove(key)
	}	
}
```


**Read/Write Through**模式中，服务端把缓存作为主要数据存储
和cache-aside基本一样，只是封装在缓存工具中
**区别是类似一个阻塞操作，只有全部返回才算完成**

**write back**
也是由缓存工具完成，但是只更新缓存，然后异步更新数据库，这种方式下，缓存和数据库的一致性不强（类似InnoDB的bufferpool）
**区别是类似一个异步操作，只有更新数据库是异步操作**


到底应该删除缓存还是更新缓存？
先操作数据库还是先操作缓存？避免中间过程存在查询，将错误数据加入缓存

延迟双删 
为什么需要？业务需要极端的一致性
优点：极端的一致性
缺点：可能导致系统响应变慢，影响整体性能


在删除缓存 更新数据库之后，延迟一段时间再次删除缓存
第一次删除是为了避免在等待的时间，有请求读到错误的数据
第二次删除是避免有请求在删除缓存 更新数据库之间的步骤进行了查询


```
func set(key,value){
	cache.remove(key) //在更新数据库之前，首先删除缓存中的数据，以避免在更新过程中读取到旧数据
	db.set(key,value)//执行数据库的更新操作
	sleep(time)//休眠一段时间,根据业务读取数据的平均耗时,避免和所有读请求冲突，等它们都结束
	cache.remove(key)//再次删除缓存中的数据，以清除可能因读请求而写入的脏数据
}
```



删除缓存失败怎么办？
1.引入重试机制
2.读取binlog异步删除
可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性