1.数据库的存 取 修改 删除
2.数据库的存储 storage

是以何种结构在数据库中和内存中存的呢？
有基于内存的数据库和基于磁盘的数据库

数据库中的数据和日志最终以物理形式存在磁盘（非易失性存储）上
查询的过程，与内存（易失性存储）交互 通过缓冲区 

磁盘的特点是，寻找的开销较大，因为这一部分涉及到转动磁盘，转动磁头（磁盘寻道）等机械动作；但是一旦找到了之后，读和写连续的比特（顺序操作）相对开销小。
所以尽量使用顺序IO而不是随机IO，利用局部性原理


磁盘中最小的传输单位叫做区（sector）。当我们执行磁盘操作的时候，这个单位就是它执行读写的最小长度了。一般来说，它的大小在 512 B 到 4 KB 之间

#### 数据库恢复
**Steal + No Force + Undo/Redo 日志 + Checkpoint**

脏页：
更新一条记录时，需要先取出到内存中，再进行修改，此时这个内存页就是脏页。
脏页不会立即写入磁盘中，而是先将redo log写入文件中，因为写入redo log是顺序IO，而将脏页写回磁盘是随机IO，性能更好。
脏页会在内存中连成一个链表。

redo log
将所有的写操作记录到redo日志中，innodb在内存中有一个redo log buffer，
新日志先写入缓冲池，在合适的时间写入磁盘文件中（ WAL（Write-Ahead Logging，日志先行）
事务提交前先写日志，再修改页（修改页的时机就是刷脏页的时机）。这里所谓的日志，就是 redo log）
这个从 redolog buffer 写到 redolog 文件中的操作，并不就是落盘操作了，这里仅仅是把 redolog 写到了文件系统的 page cache 上，最后还需要执行 fsync 才能够实现真正的落盘

redolog 可能存在的三种状态：
innodb_flush_log_at_trx_commit = 0，每次事务提交的时候，都只是把 redolog 留在 redolog buffer 中  
innodb_flush_log_at_trx_commit = 1，每次事务提交的时候，都执行 fsync 将 redolog 直接持久化到磁盘  
innodb_flush_log_at_trx_commit = 2，每次事务提交的时候，都只执行 write 将 redolog 写到文件系统的 page cache 中

默认[innodb_flush_log_at_trx_commit]设置为1，即每次提交都fsync到磁盘，os宕机也不会丢失

**. Steal 和 No Force 的定义**
**Steal（偷页）**：
    - **含义**：允许事务在提交之前，脏页（即被修改但尚未写回磁盘的数据页）可以写入磁盘。
    - **问题**：如果数据库崩溃，磁盘中可能会存在一些 **不应该存在的脏数据**。
    - **解决方法**：通过 **Undo 日志** 在恢复时撤销这些不该存在的修改。
 **No Force（不强制写回）**：
    - **含义**：允许事务提交后，数据页的写回可以异步进行，而不需要立即写入磁盘。
    - **问题**：如果数据库崩溃，磁盘中可能会 **缺少已经提交的事务修改数据**。
    - **解决方法**：通过 **Redo 日志** 在恢复时重做这些未写入的数据。

现代数据库通常采用 **Steal + No Force** 策略，因为：
- **Steal**：避免大事务占满缓冲池（Buffer Pool），提高内存利用率和系统吞吐量。
- **No Force**：减少磁盘 I/O 开销，提升性能，尤其是在高并发场景下。
但这种策略的副作用是：
- **Steal**：可能导致磁盘中有多余的（未提交）数据。
- **No Force**：可能导致磁盘中缺少部分（已提交）数据。
解决这些问题需要日志机制（Undo 和 Redo）和恢复机制。

从官方提供的说明中checkpoint分为两个：

- Fuzzy checkpoint：进行部分脏页的刷新，有效循环利用Redo日志。
- Sharp checkpoint：发生在关闭数据库时，将所有脏页刷回磁盘。

- **Checkpoint** 它是为了解决一下几个问题  

- 缩短数据库恢复的时间
- 缓冲池不够用时，将脏页刷新会磁盘
- 重做日志不可用时，刷新脏页
**LSN:** Log Sequence Number，一个本地单调递增的序号


 **DML（数据操作语句）事务的执行顺序**
按照事务的执行流程和日志机制，典型 DML 事务的步骤如下：
1. **生成 Undo 日志**：当事务修改某个页时，记录页的旧值到 Undo 日志。
2. **修改数据页**：将修改后的数据存储在内存的缓冲池（Buffer Pool）中，可能部分脏页被 Steal 到磁盘。
3. **记录 Redo 日志**：将事务的修改记录到日志缓冲区（Log Buffer）。
4. **事务提交**：
    - **将日志缓冲区刷盘**：确保 Redo 日志持久化到磁盘。
    - **返回 "Query OK"**：用户看到事务提交成功的反馈。
5. **脏页异步写回**：提交事务后，缓冲池中的脏页由后台线程异步写入磁盘。


3.sql相关：
4 b树的好处 结构 并发访问Locks 和 Latches

查询计划：两阶段算子（binary operators）和成本估算。
并发控制：多粒度锁和多锁模式
数据库恢复 数据库恢复算法: ARIES   
分布式 共识问题

没有人会使用传统的两阶段锁。基于时间戳顺序或多版本的技术可能会更流行。本节的第三篇论文讨论了 Hekaton，它实现了最先进的 MVCC 模型


大型数据流引擎

