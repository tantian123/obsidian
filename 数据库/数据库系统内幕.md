### 第一部分：存储

- **数据库管理系统架构**：介绍数据库系统的基本架构，并基于主要存储介质和布局提出数据库系统的分类方法。
- **存储结构**：比较基于磁盘和基于内存的存储结构，详细介绍B树及其变体，解释如何在磁盘上高效地维护B树结构，包括序列化、页面布局和磁盘表示。
- **日志结构化存储**：探讨几种日志结构化存储的变体，这些变体广泛应用于文件系统和存储系统的设计中，分析使用这些技术的原因和动机。

### 第二部分：分布式

- **分布式系统理论基础**：强调理解构建容错分布式系统所需理论概念的重要性，讨论分布式系统与单节点系统的主要区别，以及在分布式环境中面临的挑战。
- **分布式算法**：深入讲解分布式系统中使用的算法，包括故障检测、领导者选举、数据复制和一致性模型等，特别关注如何处理副本间的分歧和实现最终一致性。
- **数据一致性与共识算法**：讨论分布式数据库中实现数据一致性的策略，包括反熵和流言协议的作用，以及共识算法在确保分布式事务逻辑一致性方面的应用。




数据库是模块化系统，由多个部分组成：
接受请求的传输层 确定最优执行方式的查询器 执行操作的执行引擎 存储引擎

**存储引擎** ，负责在内存和磁盘上存储、检索和管理数据

使用可插拔的存储引擎使数据库开发者能够利用现有的存储引擎快速启动数据库系统，并集中精力开发其他子系统、
MySQL有多个存储引擎，包括InnoDB、MyISAM和RocksDB

======================


明确目的 是存储临时热点数据 还是长期冷存储 
有些允许复杂的分析查询，有些仅允许通过键访问值，有些优化用于存储时间序列数据，有些则高效存储大块数据

客户端请求通过传输子系统到达。请求通常以查询的形式出现
接收到请求后，传输子系统将查询传递给查询处理器，后者解析、解释和验证查询、
解析后的查询传递给查询优化器，优化器首先消除不可能和冗余的部分 找到最有效的执行方式
优化器处理查询解析所需的关联操作，通常以依赖树的形式呈现，以及优化措施，如索引排序、基数估计和选择访问方法。
查询通常以执行计划（或查询计划）的形式呈现：一系列操作，这些操作必须完成才能使查询结果被视为完整
执行计划由执行引擎执行，后者汇总本地和远程操作的结果

存储引擎有多个具有专门职责的组件：

- **事务管理器**：调度事务，确保它们不会使数据库处于逻辑不一致状态。
- **锁管理器**：对正在运行的事务锁定数据库对象，确保并发操作不会违反物理数据完整性。
- **访问方法（存储结构）**：管理和组织磁盘上的数据。访问方法包括堆文件和存储结构，如B树（参见“普遍存在的B树”）或LSM树（参见“LSM树”）。
- **缓冲管理器**：在内存中缓存数据页（参见“缓冲管理”）。
- **恢复管理器**：维护操作日志并在系统失败时恢复系统状态（参见“恢复”）
事务管理器和锁管理器共同负责并发控制（参见“并发控制”）：它们在确保并发操作尽可能高效的同时，保证逻辑和物理数据的完整性。
![[Pasted image 20241111214848.png]]
### 存储介质和布局
主要将数据存储在内存中，适合需要高性能和低延迟的应用场景，如临时热点数据存储。
主要将数据存储在磁盘上，适合需要长期存储和高数据容量的应用场景，如冷数据存储
数据按行存储，适合需要频繁读写少量字段的场景，如事务处理（OLTP）
数据按列存储，适合需要进行复杂聚合和分析的场景，如数据分析（OLAP）

本书第一部分重点讨论存储和索引结构，因此我们需要理解高层次的数据组织方法，以及数据文件和索引文件之间的关系

访问内存的速度比访问磁盘快几个数量级，因此使用内存作为主要存储介质是非常吸引人的，特别是随着内存价格的下降，这样做变得越来越经济可行

主内存数据库系统与其磁盘基对手不仅在主要存储介质上有区别，而且在使用的数据结构、组织方式和优化技术上也有所不同。

使用内存作为主要数据存储的数据库主要是出于性能、较低的访问成本和细粒度的访问考虑。对于主内存编程也比磁盘编程简单得多。操作系统抽象了内存管理，允许我们以分配和释放任意大小的内存块的方式思考。而在磁盘上，我们必须手动管理数据引用、序列化格式、已释放的内存和碎片。

内存数据库增长的主要限制因素是RAM的易失性（即缺乏持久性）和成本。由于RAM内容不是持久化的，软件错误、崩溃、硬件故障和断电都可能导致数据丢失。确保持久性的方法包括不间断电源和电池备份RAM，但这需要额外的硬件资源和运营专业知识

内存基数据库系统在磁盘上维护备份以提供持久性并防止易失数据的丢失，
在操作被认为是完成之前，其结果必须写入一个顺序的日志文件
日志记录通常以批处理方式应用于备份。一批日志记录处理后，备份将保持数据库在某个时间点的快照，此时之前的日志内容可以被丢弃。这个过程称为检查点
内存中，指针可以相对快速地跟随，随机内存访问显著快于随机磁盘访问。磁盘基存储结构通常采取宽而浅的树形结构，而内存基实现可以从更多的数据结构中选择，并进行在磁盘上难以或无法实施的优化

行存储或列存储

将相同数据类型的值一起存储（例如，数字与数字、字符串与字符串）可以提供更好的压缩比

宽列存储（Wide Column Stores）不应与列导向数据库混淆。列导向数据库按照列来存储数据，而宽列存储如BigTable或HBase则是将数据表示为一个多维映射，其中列被分组到列族（column families）中，列族通常存储相同类型的数据。在每个列族内部，数据是按行存储的。这种布局最适合存储通过键或一系列键检索的数据


##### 常见的数据存储模型

- Row-oriented
- Column-oriented
- Column-family
Row-oriented存储方式常见于关系型数据库中，比如MySQL，PostgreSQL
存储时所见即所得,更适合于运用在OLTP (Online transactional processing)系统中

Column-oriented更容易读取单列中的所有数据,同一列中数据的类型一般相同，那么就可以用同一种方法压缩数据,减少了存储数据所需要的空间。更适合于运用在OLAP (Online analytical processing)系统中

Column family/Wide-column数据库把相似的列存储在一个Column family中（列族就是基本单位）
而且我们可以不断的在这个Column family中加入新的column。每个Column family在磁盘上是存在一起的,常见的Column family数据库有Google Bigtable。

使用例子：
社交媒体平台需要存储大量的用户数据，包括用户资料、帖子、评论、点赞等。这些数据通常非常稀疏
为什么
- **稀疏数据**：用户的活动数据非常稀疏，某些用户可能有很多帖子和评论，而另一些用户可能几乎没有。（ **列式数据库**：虽然也能处理稀疏数据，但由于数据按列存储，仍然需要为每一列分配存储空间，即使某些列在很多行中没有值。
    - **行式数据库**：通常需要为每一行分配固定的存储空间，即使某些列在很多行中没有值，也会占用存储空间。）
- **高并发读写**：社交媒体平台需要同时处理大量的用户请求，包括读取用户资料、发布帖子、评论等。
- **水平扩展**：随着用户数量的增长，可以轻松地通过增加更多的节点来扩展系统。
支持多版本数据，每个列族可以存储多个版本的数据，通常通过时间戳来区分。这种设计使得数据版本管理更加灵活，适合需要历史数据的应用场景
- 使用列族来组织数据，例如：
    - `user_profile` 列族存储用户的基本信息。
    - `posts` 列族存储用户的帖子。
    - `comments` 列族存储用户的评论。
    - `likes` 列族存储用户的点赞记录。
列族`user_profile`存在列：
    - `user_id`：用户ID（行键）
    - `username`：用户名
    - `email`：电子邮件
    - `bio`：个人简介
    - `profile_picture`：头像链接

每个用户的资料可能包含不同的信息，有些用户可能没有填写个人简介或上传头像。宽列数据库可以高效地存储这些稀疏数据，因为没有值的列不会占用存储空间

![[Pasted image 20241111214433.png]]
**在宽列存储中，每行数据可以被看作是一个 Map，一组数据就是被看作一个List Map 
如果某个列在某一行中没有值，那么这个键值对就不会存在于该行的 `Map` 中**


数据库系统通常将数据文件和索引文件分开：数据文件存储数据记录，而索引文件存储记录元数据并用于在数据文件中定位记录。索引文件通常比数据文件小。文件被划分为页，通常一页有一个或多个磁盘块的大小。页可以组织成记录序列或插槽页
##### 数据文件

数据文件（有时称为主文件）可以实现为索引组织表（IOT）、堆组织表（堆文件）或哈希组织表（哈希文件）。

- **堆文件**：堆文件中的记录不需要遵循任何特定顺序，大多数时候它们按照写入顺序放置。这种方式下，当添加新页时，不需要额外的工作或文件重组。堆文件需要额外的索引结构，指向数据记录存储的位置，以便使其可搜索。
- **哈希文件**：记录存储在桶中，键的哈希值决定了记录所属的桶。桶中的记录可以按追加顺序存储或按键排序以提高查找速度。
- **索引组织表（IOTs）**：IOTs在索引本身中存储数据记录。由于记录按键排序，因此可以在IOT中通过顺序扫描实现范围扫描。

将数据记录存储在索引中可以至少减少一次磁盘查找，因为在遍历索引并定位搜索键后，我们不必再查找单独的文件来找到关联的数据记录。

当记录存储在单独的文件中时，索引文件保存数据条目，这些条目唯一标识数据记录并包含足够的信息以在数据文件中定位它们。例如，我们可以存储文件偏移量（有时称为行定位器）、数据记录在数据文件中的位置，或者在哈希文件的情况下存储桶ID。在索引组织表中，数据条目保存实际的数据记录。

##### 索引文件

索引是一种数据结构，它以一种方式在磁盘上组织数据记录，以促进高效的检索操作。索引文件被组织为专门的结构，这些结构将键映射到数据文件中存储记录的位置（在堆文件的情况下）或主键（在索引组织表的情况下）。

主文件上的索引称为主索引。在大多数情况下，我们可以假设主索引是基于主键或一组被识别为主键的键构建的。所有其他索引称为次索引。

次索引可以直接指向数据记录，或者仅存储其主键。指向数据记录的指针可以保存堆文件或索引组织表的偏移量。多个次索引可以指向同一个记录，允许可通过不同字段识别单个数据记录并通过不同索引定位。虽然主索引文件每个搜索键持有一个唯一的条目，但次索引可能每个搜索键持有多个条目。

如果数据记录的顺序遵循搜索键的顺序，这种索引被称为聚集索引（也称为聚类索引）。聚集情况下，数据记录通常存储在同一文件或聚类文件中，键的顺序得以保持。如果数据存储在单独的文件中，且其顺序不遵循键的顺序，这种索引被称为非聚集索引（有时称为非聚类索引）。

，对于数据记录应该是直接引用（通过文件偏移量）还是通过主键索引引用，存在不同的观点。

两种方法各有优缺点，最好在完整实现的背景下讨论。直接引用数据可以减少磁盘查找次数，但当记录更新或在维护过程中重新定位时，必须承担更新指针的成本。使用主键索引形式的间接引用可以降低指针更新的成本，但在读取路径上有更高的成本
例如，MySQL InnoDB使用主索引，在执行查询时执行两次查找：一次在次索引中，另一次在主索引中[1]。这增加了通过主键索引查找的开销，而不是直接从次索引跟随偏移量



存储结构有三个常见的变量：它们是否使用缓冲（或避免使用），是否使用不可变（或可变）文件，以及是否按顺序（或无序）存储值。本书讨论的大多数存储结构的区别和优化都与这三个概念之一有关。

1. 缓冲（Buffering）
缓冲是指在将数据写入磁盘之前，先在内存中收集一定量的数据。这样做的目的是减少磁盘I/O操作，提高性能。
- **优点**：减少磁盘I/O次数，提高写入性能。
- **缺点**：增加了内存使用，如果系统崩溃，可能会丢失未写入磁盘的数据。
2. 不可变性（Immutability）
不可变性是指一旦数据写入磁盘，就不再修改。新的数据会被追加到文件的末尾，而不是覆盖原有数据。
- **优点**：简化了数据管理和恢复过程，减少了锁竞争。
- **缺点**：需要更多的磁盘空间，因为旧数据不会被立即删除。
3. 排序（Ordering）
排序是指数据记录是否按键值顺序存储在磁盘上的页面中。
- **有序存储**：数据按键值顺序存储，适合范围查询。
- **无序存储**：数据按插入顺序存储，适合写入密集型工作负载


在本章中，我们讨论了数据库管理系统的架构，并介绍了其主要组成部分。

为了强调基于磁盘的结构及其与基于内存的结构的区别的重要性，我们讨论了内存和磁盘存储。我们得出结论，基于磁盘的结构对这两种存储都很重要，但它们的用途不同。

为了理解访问模式如何影响数据库系统的设计，我们讨论了列导向和行导向数据库管理系统以及它们之间的主要区别。为了开始关于数据存储方式的讨论，我们涵盖了数据文件和索引文件。

最后，我们介绍了三个核心概念：缓冲、不可变性和排序。我们将在本书中使用这些概念来突出使用它们的存储引擎的特性



适合用于存储结构的数据类型要满足：

- 适合磁盘存储，IO要小且一次读取连续的区域，如大文件、数组、B树、LSM树。
- 允许并发操作，增删改对存储结构的影响要小，如链表、哈希表、二叉搜索树、B树、LSM树。

**扇出：**每个节点拥有的最大子节点数；扇出与高度负相关，扇出越高，高度越低。

**适合磁盘的树需要满足：**

- 高扇出，以改善邻近键的数据局部性
- 低高度，以减少遍历期间的寻道次数

**B树允许在任意节点上存储值，B+树只允许在叶节点上存储值，内部节点仅仅存储分隔键。**

**B树是自上而下构建的，B+树是自下而上构建的，随着叶节点的增加，内部节点的数量和树的高度随着增加。**





数据库的存储引擎，其中主要涉及两个数据结构：
1. B 树（包括 B 树、B+ 树以及其他变体）
2. LSM 树
这二者的区别在于 B 树是可变的存储结构，在修改时直接操作磁盘上的原纪录，而 LSM 可以作为不可变存储结构，仅支持追加存储(这在分布式系统中是个非常巨大的优点 大幅简化了分布式存储系统的复杂度)
事务处理主要在内存中进行
包括原理、实现、使用等，对于可变性，重点介绍了节点的分裂与合并、页布局，即如何编码数据、组织数据等。

对于 LSM 树，首先介绍其结构，一般包括两部分：内存表（MemTable）、磁盘表（SSTable），其中磁盘方面考虑到后期读时的优化，又可以再加一个压实（Compaction）的表。然后提到不可变结构面临的共通问题：

1. 读放大：为了检索数据而读取多个表
2. 写放大：压实过程带来额外的写
3. 空间放大：一条记录可能同时出现在多层

最后介绍 LSM 的一些实现细节，包括布隆过滤器，采用跳表作为内存表的存储结构等



主要介绍了分布式系统中的一致性概念，这部分的内容可圈可点，其中提到了各种一致性模型，包括：

- 严格一致性
- 可线性化
- 顺序一致性
- 因果一致性




## 并发控制

**乐观并发控制（OCC）:** 允许多个事务执行并发的读写操作，最后确定执行结果是否被串行化；事务不会彼此阻塞，而是保留操作历史，在提交前检查这些历史操作是否存在冲突，存在冲突则终止其中一个冲突。

**多版本并发控制（MVCC）:**允许一条记录同时存在多个时间戳的版本，以此保证事务读到的是数据库过去某个时刻的一致试图。

- 实现方式：只允许多个更新或事务提交中的一个成功。
- 无所技术：比如时间戳排序。
- 基于锁实现：如两阶段锁。

**悲观并发控制（PCC）：**基于锁的实现，要求事务维护数据库记录上的锁；不加锁的实现根据未完成的事务调度，即维护读取和写入的操作列表以限制事务的执行。

  

**读异常：**

- 脏读：一个事务能读到其他未提交的事务
- 不可重复读：同一事务两次查询同一行得到不同的结果。
- 幻读：同一事务两次查询同样的行集合（即不是读取单行数据，而是一个范围数据）得到不同的结果。

**写异常：**

- 丢失更新：两个事务同时更新数据，由于两个事务不知道彼此的存在，则会存在覆盖先提交的事务的更新的值。
- 脏写：事务拿到一个未提交的值（脏读），对其进行了修改并保存。
- 写倾斜：单个事务都遵循约束，但是组合之后违反了约束。


innodb采用磁盘索引而不是内存索引 
 MEMORY引擎  是一种将数据存储在内存中的存储引擎  MEMORY引擎使用哈希索引来存储数据



讨论一下为什么要考虑传统搜索树的替代方案，例如二叉搜索树、2-3 树和 AVL 树[KNUTH98]。为此，让我们回忆一下二叉搜索树是什么

Tree Balancing 树平衡
在平衡树中，沿着左或右节点指针查找平均会将搜索空间减少一半，因此查找复杂度为对数： `O(log2 N)` 。如果树不平衡，最坏情况下的复杂度会上升到 `O(N)` ，因为我们可能最终会陷入所有元素都在树的一侧的情况。

保持树平衡的一种方法是在添加或删除节点后执行旋转步骤
如前所述，不平衡树的最坏情况复杂度为 `O(N)` 。平衡树为我们提供了一个平均 `O(log2 N)` 。同时，由于扇出较低（扇出是每个节点允许的最大子节点数），我们必须经常进行平衡、重新定位节点和更新指针。维护成本的增加使得 BST 作为磁盘上的数据结构不切实际

如果我们想在磁盘上维护一个 BST，我们会面临几个问题。一个问题是局部性：由于元素是随机添加的，不能保证新创建的节点被写入到其父节点附近，这意味着节点子指针可能跨越多个磁盘页面。

考虑到这些因素，一种更适合磁盘实现的树的版本必须具备以下属性
**高扇出**以提高相邻键的**局部性**
**低高度**以减少遍历时的**寻道次数**
当数据量非常大，以至于无法将整个数据集都保留在内存中或不可行时，通常会使用磁盘上的数据结构。任何时候只能将一小部分数据缓存在内存中，其余数据必须以允许有效访问它的方式存储在磁盘上

B 树允许在任何级别存储值：在根、内部和叶节点中。B + -树仅在叶节点中存储值。内部节点仅存储用于引导搜索算法到存储在叶级上的相关值的分隔键


总结
二叉搜索树可能具有类似的复杂特征，但由于扇出低以及平衡导致的大量重定位和指针更新，仍然不适合磁盘。B 树通过增加每个节点存储的项数（高扇出）和减少平衡操作的频率来解决这两个问题。




# 文件格式

必须提出一种易于构建、修改和解释的文件格式
#### Page Structure 页面结构

InnoDB 中，**每个叶子节点是一个页（Page**

数据库系统将数据记录存储在数据和索引文件中。这些文件被划分为固定大小的单位，称为页，通常每页的大小为多个文件系统块。页的大小通常在 4 到 16 kb 之间

slotted page是数据库中页的常见组织形式。优点是可以存储可变长的tuple。其核心是通过slot 数组中存储的偏移值来查找page中的某个tuple具体内容是什么。即可以通过page号和slot 号就可以查询磁盘上任意一个tuple的内容


在 Innodb 中，对于任何数据的查询和修改，最终都是落在磁盘物理文件的访问操作中。简单来说，是通过 btree 定位到具体的物理 page，对 page 内部的 record 进行增删改查。Btree Page 内部本身可以看作一个有序的 record **单向链表**，通过一些元信息对 16 KB 的物理空间进行高效管理和组织。每个 Page 中存在两个特殊的 record：infimum record 和 supremum record，分别代表 page 中 record 的无穷小和无穷大，位于 record 链表的头和尾

在操作 btree 过程中，将访问的 page 指针、请求的锁 latch、以及产生的 redo log 分别挂在 mtr 上，当操作流程结束提交 mtr 时，将 redo log 同步到全局 log buffer 中，将脏页加入 flush list 上，最后释放所有持有的 latch。真正修改只有在 mtr commit 提交，redo 落盘才生效，因此 mtr 的实现将上层对记录的操作可以看作一个对 btree 的原子操作，也是 cursor 搜索并发控制的基本单位

