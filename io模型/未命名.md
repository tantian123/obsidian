非阻塞I/O，就是进行系统调用如果不能立马完成（慢系统调用） 就返回错误  
阻塞I/O会让程序一直等待，直到操作完成或遇到错误

为什么需要IO多路复用：程序需要同时处理多个输入输出流
如果使用阻塞IO 解决方案是使用多线程或者多进程
如果使用非阻塞IO 解决方案是轮询（一个流的输入不可用就会继续处理下一个，缺点是浪费cpu）
异步IO 是通过通知机制来解决等待的问题（进程 让操作系统在文件描述符准备好之后通过信号通知进程，此时进程可以执行其他任务） 但是如果同时有多个文件描述符就绪，一个信号是不够用的，不知道是哪个文件描述符好了，所以仍然需要遍历一次所有文件描述符进行非阻塞IO操作
IO多路复用为这个问题提供了解法，
同时监听多个文件描述符，程序就不用为每个文件描述符做单独的阻塞等待
IO多路复用有三个系统调用接口：
select poll pselect
这几个函数运行一个进程同时监听多个文件描述符，避免阻塞式操作

select的局限性：最多支持1024个文件描述符
poll 没有文件描述符限制 缺点是仍然是阻塞的 大量的文件描述符下性能不佳
pselect 功能和select一致 提供了更多特性


`select` 和 `poll` 函数，是一种同步通知形式。系统在我们调用 `select` 或 `poll` 时才会告诉我们发生了什么

aio:
**信号**提供了一种异步通知形式，告诉我们某个描述符上发生了某些事情
异步 I/O 的形式是有限的：它们并不适用于所有文件类型，而且只允许使用一个信号。如果我们启用了多个描述符进行异步 I/O，我们无法知道信号对应的是哪个描述符

内存映射I/O（Memory-mapped I/O）允许我们将磁盘上的文件映射到内存中的缓冲区，这样当我们从缓冲区读取字节时，相应的文件字节会被读取。类似地，当我们将数据存储到缓冲区时，相应的字节会自动写入文件。这样，我们就**可以在不使用读取（read）或写入（write）操作的情况下执行I/O。**





===============================

非阻塞I/O（就是进行系统调用如果不能立马完成 就返回错误  
阻塞I/O会让程序一直等待，直到操作完成或遇到错误
）
系统调用可以分为两类：“慢”系统调用和所有其他系统调用。慢系统调用是指那些可能会一直阻塞的调用。它们包括：
- 读取操作（如果某些设备类型的数据不可用，可能会阻塞）
- 写入操作（如果数据不能立即接受，也会阻塞）
- 打开操作（某些设备可能会阻塞，直到某个条件发生）
- 强制记录锁定的读取和写入操作
- 一些控制操作（ioctl）
- 某些进程间通信功能

虽然磁盘I/O相关的系统调用可能会暂时阻塞调用者，但它们并不被视为“慢”调用。

**非阻塞I/O** 允许在无法立即完成时，系统调用立即返回错误，表示操作会被阻塞，避免了永久阻塞。可以通过以下两种方式设置非阻塞I/O：

1. 在使用 `open()` 打开文件描述符时，可以指定 `O_NONBLOCK` 标志。
2. 对于已经打开的描述符，可以通过 `fcntl()` 设置 `O_NONBLOCK` 标志
在非阻塞模式下，写操作可能无法一次性写完所有数据。如果目标是终端设备，可能会多次尝试写入，并在无法写入时返回错误（如 `EAGAIN`）。这种方式会导致程序进行多次“轮询”，可能浪费CPU资源。
为了避免这种情况，通常可以使用I/O多路复用或者多线程等技术，以更高效地处理非阻塞I/O操作。
总结来说，非阻塞I/O是为了避免在I/O操作无法完成时导致程序阻塞