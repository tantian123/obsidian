
[(71 封私信 / 80 条消息) CPU 的工作原理是什么？ - 知乎](https://www.zhihu.com/question/40571490/answer/2762053870)

多核
多级缓存
L1分为指令缓存和数据缓存 是独享的
L3的核之间的共享


### 现代计算机架构





经典架构
计算单元(处理器)，数据存储单元，程序存储单元

冯诺依曼架构，数据存储单元和程序存储单元是同一个硬件：内存
哈弗架构，数据存储单元和程序存储单元对应不同的硬件，读写的时候两者使用不同的总线（不会因为需要访问内存上的数据造成指令堵塞），
这就有利于处理大批量的数据

![[Pasted image 20241214183905.png]]



现代计算机架构
指令和数据都存储在一个存储器上，并且通过一个系统总线进行访问
并且在L1高速缓存上，还区分了指令缓存和数据缓存，并进一步提升系统总线的访问速度




多 CPU 架构，每颗 CPU 又会包含多个物理核，每个物理核又可以超线程出多个逻辑核来供操作系统管理和使用
拿某台线上的服务器 32 核的服务器来举例，该服务器实际上是有 2 颗 CPU，每颗 CPU 包含了 8 个物理核心。这样总共包含的是 16 个物理核。
因为该服务器每个物理核心又可以当成两个超线程来用，所以通过 top 命令可以看到有 32 “核”，这里看到的核其实是逻辑核。




操作系统是如何调度CPU给线程的

为了满足各种复杂的调度策略,不同的调度需求的进程放在不同的调度类中
 **实时调度器** 
 定义一些优先级，并为每个优先级各分配一个链表当队列即可，也叫多优先级队列
 高优先级的进程可以抢占低优先级进程 CPU 资源来运行
**完全公平调度器**
对于绝大部分的用户进程来说，对实时性的要求没那么高。如果因为优先级的问题频繁地发生抢占，进而导致过多的进程 上下文切换的开销，对系统整体的性能是有不利的影响的。

Linux 2.6.23 之后采用了完全公平调度器（Completely Fair Scheduler，CFS）作为对用户进程的调度算法。**CFS 调度器的核心思想是强调让每个进程尽量公平地分配到 CPU 时间即可，而不是实时抢占**

举个例子，假设一个 CPU 上有两个任务需要执行，那么每个任务都将分配 50% 的 CPU 时间，以保障公平性。假如有 N 个任务，CPU 尽可能分配给每个进程 1/N 的处理时间

公平调度算法在实现上引入了一个虚拟时间的概念。一旦进程运行虚拟时间就会增加。尽量让虚拟时间最小的进程运行，谁小了就要多运行，谁大了就要少获得 CPU。最后尽量保证所有进程的虚拟时间相等，动态地达到公平分配 CPU 的目的

在 CFS 调度器中采用的解决办法是使用的是**红黑树**来管理任务。
红黑树把进程按虚拟运行时间从小到大排序。越靠树的左侧，进程的运行虚拟时间越小。越靠树的右侧，进程的运行虚拟时间就越大

完全公平调度器实现上考虑到的两个细节：
1.Linux 会保证选择到的进程一个最短的运行时间
2.在是上述绝对公平算法基础上再为进程引入一个权重。通过给每个进程设置一定的权重，各个进程按权重的比例公平地来分配 CPU 时间。如果进程的权重高，那就按比例多获得一点 CPU，权重低获得的比例就低
这个权重就是 Linux 进程的 nice 值，也就是我们平时 top 命令结果中看到的 ni 这一列。nice 范围为 -20（最高权重）到 19（最低权重）
现在有很多人都把 nice 理解成了优先级，这是不太恰当的。优先级强调的是抢占，高优先级比低优先级有优先获得 CPU 的权利


每个 CPU 核都有一个对应的运行队列 runqueue (struct rq)。所以新进程在加入调度前的第一件事就是选择一个合适的运行队列。然后使用该任务队列中，并等待调度



**CPU 调度是在缓存性能和空闲核心两个点之间做权衡**。 同等条件下会尽量优先考虑缓存命中率，选择同 L1/L2 的核，其次会选择同一个物理 CPU 上的（共享 L3），最坏情况下去选择另外一个物理 CPU 上的核心。



一个进程从 fork 创建出来到最后真正能获得 CPU 并进行运行，中间有很多的内核逻辑需要处理，我把它分成了这么几个步骤供你更容易地理解。
第一，每个 CPU 核都有一个运行队列。为了支持不同的调度需求，运行队列是由实时调度器、完全公平调取器等多种调度器组成

进程在 fork 的时候会选择自己的调取器，用户进程一般都是用完全公平调度器
进程创建完前会综合考虑缓存友好性以及空闲状况，选择一个 CPU 运行队列出来，并将新进程添加到该队列中

内核有很多的时机来触发调度。我们文中举了同步阻塞网络 IO 放弃 CPU 时调取新进程运行的例子。在放弃 CPU 前会从当前 CPU 的运行队列获取一个进程出来，上下文切换后运行之


进程不主动释放 CPU 的话，每次调度最少能运行多久？  
在完全公平调度器中，出于减少频繁切换进程所带来的成本考虑，一个进程一旦被分配到 CPU 就会持续运行相对较长的一段时间，避免频繁的进程上下文切换导致的性能损耗
当然了，如果进程因为等待网络、磁盘等资源时主动放弃 CPU 那另算


对于用户进程来讲，一般都采用的完全公平调度器来进行 CPU 资源的分配。在这种调取器中，其 nice 其实是一个权重的概念。权重高的进程获得的 CPU 比例会相对高一些。但不是实时抢占。