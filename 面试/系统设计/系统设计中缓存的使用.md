使用场景： 读多写少（即更新频率不高）一致性和实时性要求不高


总结：更新缓存这个操作是无法保证数据库和缓存的一致性的，因此**推荐删除缓存**
关于 先删数据库 还是先删缓存的方案，如果是先删缓存 业界采用比较多的是延迟双删，但是延迟的时间不好估计，
如果是**先删数据库** 在并发场景下大概率是没有数据一致性的问题的，但是为了保证这两个操作的执行，需要异步执行即使用消息队列或者监听binlog

很难做到强一致性CP，通过**超时时间的兜底** 还是能**保证最终一致性**AP的


一致性问题的分析方式：增删改查
1.数据库新增一条数据，缓存中此时没有，如果此时有查询请求，会先查缓存找不到再去查数据库，没有一致性问题
2.数据库删除一条数据，此时分类讨论 先删数据库再删缓存，先删缓存再删数据库。
先删缓存再删数据库：如果此时有查询，没查到缓存，他就去查数据库然后又把数据放到缓存中去了，最终的结果就是 缓存中有数据 数据库中没数据
先删数据库再删缓存(此时缓存可能是过期了的)：如果同时有两个线程 一个执行删除 一个执行查询，T2线程查询了数据库 还没塞到缓存中去，此时T1线程删除了数据库 再去删掉缓存，然后T2再把数据塞到缓存
最终的结果就是 缓存中有数据 数据库中没数据
3.数据更新 先更新数据库再更新缓存  先更新缓存再更新数据库
先更新数据库再更新缓存 T1线程更新了数据库还没更新缓存 此时T2线程更新数据库并更新成功了缓存，然后T1再更新缓存
4.先更新数据库再删除缓存 这种方案避免了多线程更新的并发问题，但是如果是一查一删，  又会有并发问题 
这种情况要满足两个条件  缓存此时过期 还有就是更新数据库+删除缓存的时间比更新缓存短
T1线程读取数据 缓存此时未命中 查数据库 但是还没更新缓存
此时T2线程更新数据库 并删除缓存 然后T1再更新缓存
表面上看是有问题的，但是(更新数据库+删除缓存的时间比更新缓存短)这个条件太苛刻


几种模式
Cache Aside 同时更新缓存和数据库
Read/Write Through 先更新缓存，缓存负责同步更新数据库
Write Behind Caching 先更新缓存，缓存负责异步更新数据库

1.读时 先从cache中查询，取到就返回 取不到就查询数据库，然后把结果放到缓存中
写时 把数据更新到数据库中 然后再清除缓存

有几个一致性的问题



2 .查询操作中更新缓存，缓存服务自己来加载

3.在更新数据的时候，只更新缓存，不更新数据库


延迟双删：降低概率
删两次 第二次延迟




**超时时间作为兜底，保证了我们的最终一致性**

多节点的缓存刷新问题
如何保证多副本之间的强一致，现在的方案只是最终一致 -> 加锁->性能查 违背了缓存的目的


处理库和缓存数据一致性问题的常用方案： 异步线程刷缓存或者发消息(监听mysql binlog 或者flink cdc)  canal+MQ
**推荐采用「先更新数据库，再删除缓存而不是更新缓存」方案，然后配合「消息队列」或「订阅变更日志」的方式来做**。
为什么？




还有单线程场景下发生的问题：如果删除缓存的操作失败了呢
1.引入消息队列 采用失败重试
2.订阅数据库变更信息 

