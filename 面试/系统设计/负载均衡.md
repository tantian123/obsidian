负载均衡算法：
静态负载均衡：
轮询  round robin
加权轮询   
hash（用ip做哈希）
动态负载均衡：
最少连接（负载均衡器将检查哪些服务器的活动连接最少，并将流量发送到这些服务器）
加权最少连接 
基于资源的方法




**DNS 实现负载均衡**（没人这样做 因为太简陋）
DNS 实现负载均衡是最基础简单的方式。一个域名通过 DNS 解析到多个 IP，每个 IP 对应不同的服务器实例，这样就完成了流量的调度，虽然没有使用常规的负载均衡器，但实现了简单的负载均衡功能。

负载均衡软件：
Nginx/LVS/HAProxy

成熟架构：
LVS+Keepalived、Nginx+Keepalived、HAProxy+Keepalived


ng优点：
简单，单机一般能支撑几万次的并发量，有负载均衡 反向代理等功能

缺点：
仅能支持http、https和Email协议


LVS
因为LVS工作在网络4层，所以它几乎可以对所有应用做负载均衡，包括http、tcp、数据库、在线聊天室等
大型网站LVS+Keepalived实施起来就比较复杂，配置成本高

HAProxy



## 常见[微服务](https://www.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22366204416%22%7D)框架的负载均衡
Dubbo 支持4种算法（随机、轮询、活跃度、Hash一致性）
SpringCloud Feign支持很多种算法，包括：轮询、随机、最小连接、区域加权、重试以及ResponseTime加权。也可以自己实现负载均衡算法



ngnix架构图
![[Pasted image 20240409225356.png]]

总结：是一个模块化的、事件驱动的、异步的、单线程的、非阻塞的架构 
nginx 大量使用多路复用和事件通知，并将特定任务分配给单独的进程
nginx 不会为每个连接生成一个进程或线程，内存使用非常保守和极其高效。 nginx 还节省 CPU 周期，因为进程或线程没有持续的创建-销毁模式
ngnix的内存管理：nginx 尽可能避免在内存中复制数据，并且大多数数据是通过指针值传递的，而不是通过调用 memcpy。


关键点：是**多进程**（分为master进程和work工作进程）
**事件驱动模型**（异步非阻塞机制）
**模块化**：HTTP 模块（处理 HTTP 请求和响应）、事件模块（处理底层的事件通知机制，如 Epoll、Kqueue 等）、解析器模块（解析 Nginx 配置文件）
功能：代理服务器 负载均衡 限流（有参数 限制单位时间内的请求数 限制同一时间连接数=>采用的漏桶算法）




nginx是如何实现高并发的？
=>事件驱动机制 采用异步非阻塞IO  webserver 刚好属于网络 IO 密集型应用，不算是计算密集型

Nginx高并发的因素大致可以归纳为以下几点：
1. I/O多路复用：从select到poll
2. 事件通知（异步）：从poll到epoll
3. 内存映射文件：从读文件到内存映射文件 
4. **Processor Affinity：**一个Core指定分配一个进程数（根据CPU核心数目确认并发的进程个数）
5. 进程单线程模型：避免了线程切换开销 
6. 线程池功能（1.7.1+），将可能阻塞的I/O模块扔到线程池里去



nginx为什么不使用多线程？
多线程会带来线程上下文切换的开销
多线程模型通常需要为每个线程分配一定的栈空间，而对于大量并发连接的情况下，这可能会消耗大量的内存。Nginx 的单进程模型可以减少内存消耗
高可用性(进程之间的隔离保证了安全，同时如果使用多线程 挂掉一个整个进程都会受影响)


location指令
location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作

什么是动静分离 如何做
动态资源、静态资源分离 
指定路径对应的目录


ngnix如何实现限流的？
Nginx的限流都是基于漏桶流算法


漏桶和令牌桶
漏桶算法思路很简单，我们把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流
令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。
系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token），当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。
### **正向代理和反向代理**
（一句话就是正向代理是你自己配的 反向代理是无感的）
客户端在进行**翻墙**操作的时候，我们使用的正是正向代理，通过正向代理的方式，在我们的客户端运行一个软件，将我们的HTTP请求转发到其他不同的服务器端，实现请求的分发。
反向代理服务器作用在服务器端，它在服务器端接收客户端的请求，然后将请求分发给具体的服务器进行处理，然后再将服务器的相应结果反馈给客户端。Nginx就是一个反向代理服务器软件。