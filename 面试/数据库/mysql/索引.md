目录：
索引的数据结构 
使用场景
索引分类
索引的优化
索引失效场景
索引下推



是一种空间换时间的数据结构
使用场景 where语句 group by order by



索引的底层数据结构：

1.Hash 优点是常数时间复杂度，缺点是只适用于等值查询 不支持范围查询
2.二叉搜索树BST 优点是支持范围查询，缺点是极端情况退化为On
3.自平衡状态的二叉树有 AVL 树和红黑树，缺点是单个节点只能存储一个数据

4.由于查询的消耗大部分是磁盘IO，并且读取的数据大小影响不大，所以每个节点尽可能存储多的数据
B树节点存储的是数据，**B+树存储的是索引，不直接存储数据，只有叶子结点存储数据**，这样一个节点能容纳更多的索引，可以将树的高度降低即扫磁盘的次数减少
同时**叶子结点之间用链表连接起来**，方便范围查找（例如select * from user where id>10 只需要找到10然后向后遍历）

MyISAM和Innodb 引擎的底层实现（**数据和索引到底怎么组织起来**，不同的思路导致了这两种引擎的出现）
MyISAM 引擎把数据和索引分开不在同一个文件，这叫做非聚集索引方式；Innodb 引擎把数据和索引放在同一个文件里了，这叫做聚集索引方式。
但是二者都是通过B+树实现的，MyISAM**不区分主键索引和非主键索引**的索引树结构，
索引树的叶子节点存储数据的物理地址，然后去数据文件中读取这个数据
InnoDB 通过**在主键索引树的叶子节点存储实际数据记录，对于非主键的二级索引，叶子节点存储的是对应记录的主键值**而不是实际数据，拿到主键值还要再去主键索引树搜索一次


全文索引：显著提高了对大文本字段的搜索性能，底层是**倒排索引**

何时使用索引：where语句 groupby orderby  何时不使用：字段重复率高 数据少



索引的分类
按照物理层面索引放的位置，分为聚集索引和非聚集索引（主键上建立聚集索引）
按照字段分为 主键索引 唯一索引(unique字段上的索引) 普通索引 前缀索引（用于字符类型 对前几个字符进行索引）  当使用普通索引进行查询时，首先根据普通索引定位到对应的主键值，然后再通过主键索引定位到实际的数据行即回表
按照字段个数 分为联合索引/复合索引（使用联合索引时，存在**最左匹配原则**，即
索引是(a,b,c).那么它可以支持`(a),(a,b),(a,b,c)` 3种组合进行查找
）和单列索引

理解最左匹配原则，需要了解联合索引的底层实现（每个节点存储多个键值 ）
即：叶子节点拥有联合索引中的所有字段以及主键字段，且**叶子节点数据局部有序**

![[Pasted image 20240518234256.png]]

思考：给出相同的数据 根据不同的建立索引的类型 画出不同的索引树



索引优化
联合索引区分度大的放前面，主键索引设为自增（减少页分裂），避免索引失效，字符串类型的前缀索引优化，覆盖索引优化

**覆盖索引**：select a,b,c from table where a=1 and b = 1 此时如果由于复合索引(a,b,c) 就不需要回表再查


索引失效
左右模糊匹配 ，函数 类型转换 ，多个条件用OR 存在不是索引列的

索引下推 在多查询条件下，利用二级索引的其他列对第一列进行筛选，减少回表的次数
例如select * from user where name=2 and age=1 尽量建立联合索引(name,age)减少回表次数


[深入理解 Mysql 索引底层原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/113917726)
