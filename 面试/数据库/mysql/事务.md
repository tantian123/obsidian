事务是什么
事务的特性
隔离级别和实现原理
事务并发会出现的问题


事务特性：ACID
原子性 同一事务的操作要么全部成功，要么全部失败  原理是基于undolog版本链 
一致性 事务保证数据库从一个一致的状态到另一个一致的状态，这是有AID三个特性保证的
隔离性 事务之间不会互相影响，影响的程度由隔离级别控制， 这是通过MVCC和锁实现的
持久性 事务一旦提交，就不会因为系统崩溃丢失，这是由redolog实现的

隐式事务：增删改 update insert delete语句  由mysql内部控制
显示事务：BEGIN和COMMIT语句


redoLog相关：
原因：innodb通过内存缓冲区读取数据，避免每次都访问磁盘

如果事务执行完成，但是数据还在内存中，没有刷入磁盘，此时如果宕机，
因为存在redoLog 在重启时，会自动执行未执行的redolog 将数据刷入磁盘



并发事务的问题：脏读  不可重复读 幻读
事务A执行过程中，修改了某条数据，此时事务B访问了这条数据，但是事务A回退，事务B就读到了脏数据
事务A执行过程中，事务B在事务A执行的前后中读了两次，两次读取的数据不一致
事务A执行过程中，事务B读取了数据，但是事务A回退，事务B读取到了条数不同的数据
隔离级别：读未提交 读已提交 可重复读 串行化


隔离级别是如何解决事务并发问题的（mysql使用锁和mvcc来实现四种隔离级别）
读未提交：读不加锁 写加排他锁
读已提交：MVCC
可重复读 ：MVCC
串行化：所有的select语句隐式转化为select for share 即加锁


MVCC
innodb中MVCC是基于锁和多版本控制实现的，其他数据库有例如基于TimestampOrdering的方式

readview：活跃ids min_id max_id
判断数据的可见性，就是沿着版本链依次匹配，将事务的id和版本匹配
如果当前事务id在活跃ids内，代表当前快照生成时，事务仍然在执行，所以该readview对事务不可见
事务id<min_id 可见， id>max_id 不可见



了解MVCC 先了解并发控制的策略
MVCC有基于时间戳(oracle)和基于活跃事务表(mysql)两种方式

MVCC模型在MySQL中的具体实现则是由 **4个隐式字段**（判断可见性的），**undo日志**（版本链） ，**Read View**（快照） 等去完成的
针对于不同的隔离级别（read commit和repeatable read），无非就是read commit隔离级别下，每次都获取一个新的read view（每次读取都能反映最新的已提交状态 解决了脏读的问题）
repeatable read隔离级别则每次事务只获取一个read view，即可重复读的情况下 一个事务只会在一开始生成一个reaDVIEW（所以不会出现不可重读的情况，因为读的都是同一个快照）


幻读是如何解决的