单位：
字节 byte  1 字节（8 位） 是计算机内存分配的基础单位
位 又叫比特 bit 是最小的数据单位 
字长 大小取决于处理器的架构   表示计算机处理器在一次操作中可以处理的位数（对应的也是寄存器大小，例如32位机器的字长就是4字节）
cpu位数=cpu的寄存器位数=cpu一次处理数据的宽度
操作系统位数=其指令集的位数<=cpu位数



基本数据类型 
整型 byte  short int long  1 2 4 8 
浮点型 float double   4 8   单精度浮点数，双精度浮点数
boolean 1 
char 2 ，表示单个 16 位 Unicode 字符，范围为 0 到 65,535（2的16次方-1）

java没有无符号的整数，int可以表示正数 负数和0
所以java中int的范围是-2的31次方到2的31次方-1（第一位是符号位）

float和double的范围：
float 1+8+23 符号位加指数位加尾数位
double1+11+52
例如，单精度浮点数 `6.5` 的二进制表示是 `110.1`，可以写成规范化形式
![[Pasted image 20241109155637.png]]
1是隐含位，不存储在尾数部分中，但它被视为有效数字的一部分  0.101是实际的尾数存储的部分

即使单精度浮点数的尾数部分有 23 位，实际上可以视为有 **24 位有效数字**（23 位存储 + 1 位隐含位）

浮点数的精度 精度这里指的是最大有效数字的位数，即只需要考虑尾数部分就可以啦
对于float类型，尾数部分是23，转换成10进制的精度
![[Pasted image 20241109160430.png]]

float 约为 6-7 位十进制数字  24×log10​(2)≈24×0.3010=7.2
double约为 15-16 位十进制数字



浮点数在内存中是如何存储的？IEEE 754标准 （**其实就是转为科学计数法**）
![[Pasted image 20241109154915.png]]
**指数位** 决定浮点数的大小范围
**尾数** 决定浮点数的精度
浮点数有精度问题的根源：
1.某些十进制小数在二进制中是 **无法精确表示的**，如 0.1 和 0.2。
2.浮点数中的尾数位数是有限的 舍入有误差

例如，当我们在计算机中执行 `0.1 + 0.2` 时，结果并不是 0.3，而是一个接近 0.3 的数


以上知识主要的应用场景是浮点数的序列化


Integer等包装类的内存占用：
对象头加实例数据加内存对齐
对象头包括markword标志位和klasspoint类指针 
实例数据 
Integer：1字长+1字长+4字节（int大小）+对齐数据

markword存储对象运行时数据 例如hashcode gc年龄 锁标志

类比举例：薯片 商品包装就是对象头 markword是商品的简介，类指针是二维码，薯片是实例数据，氮气是填充的字节


JOL的使用

