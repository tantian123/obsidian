是一层抽象，屏蔽操作系统和硬件的差异 

1.多核计算机CPU之间，存在高速缓存
2.编译器优化导致重排序/指令集并行重排序 /内存系统重排序
由于CPU的优化，指令乱序执行，即可见性
3.修改操作往往是非原子性的 例如i++

问题1：缓存锁和总线锁
问题2：为了解决这个问题 提出了内存屏障
读屏障 写屏障 读写屏障

CPU发现写屏障时，会将屏障前的所有写指令都刷入高速缓存（禁用CPU的优化），进而让CPU修改的数据可以马上暴露给其他CPU，达到「写操作」可见性的效果

问题3：


总结：
由于不同CPU架构的缓存体系不一样、缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化Java开发人员的工作。Java封装了一套规范，这套规范就是「Java内存模型」



java内存模型的内容
	java内存模型结构 
	happen-before规则 
	volatile内存语义

结构：java内存模型的主内存和本地内存
共享变量存储在主内存中，它的副本保存在线程各自的本地内存中
内存模型强制要求线程只能修改本地内存中的

![[Pasted image 20230918213317.png]]

happen before
略

volatile 保证可见性和有序性
是java内存模型定义的规范，由java虚拟机实现。
会在volatile「前后」加上「内存屏障」，使得编译器和CPU无法进行重排序，并且写volatile变量对其他线程可见