垃圾收集的过程：识别垃圾 垃圾分类（通过分代来优化GC） 垃圾处理

调优的重要参数：吞吐量，响应能力



1.识别垃圾的方式
引用计数法和可达性分析
引用计数法优点是使用简单快速， 缺点是循环引用 占用了额外空间
可达性分析优点是可以解决循环依赖问题 不占用额外空间 缺点是无法立即识别出垃圾 需要STW暂停整个程序
如何判断是否可达
GCROOT：


2.垃圾处理
标记清除 优点是简单 缺点是需要完全暂停程序 并且内存碎片化
复制 优点是不用全部扫描对象 只需要复制可达的对象，解决了内存碎片的问题，缺点是占用内存空间大
标记整理 避免了内存碎片化  缺点是时间久



3.java内存布局和垃圾回收范围
堆 虚拟机栈 本地方法栈 程序计数器 元空间
（方法区是一种规范  而永久代（1.8以前）和元空间是它的具体实现） 永久代是会触发FullGC的 
元空间是使用操作系统的内存空间 

（区别是否是线程共享来判断是否进行GC）gc的范围是堆和方法区 ，其他区域都是线程私有的，即随着线程的创建而创建，随着线程的销毁而销毁

4.GC触发时机


5.垃圾收集器
分为年轻代、老年代、混合（G1）
**Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old以及CMS，G1收集器**
Serial是单线程的，Parallel是多线程
CMS（Concurrent Mark Sweep） 并发标记清除
用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是「并发」：在GC线程工作的时候，用户线程「不会完全停止」，用户线程在「部分场景下」与GC线程一起并发执行。
CMS避免了长时间的stw 只在部分场景是并发的



对象怎么从年轻代到老年代






