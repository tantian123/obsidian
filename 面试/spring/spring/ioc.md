ioc 控制反转
为了解决依赖管理和统一对象管理的问题

从依赖管理的层面，**解耦**，如果高层依赖很多底层的包 ，当做单元测试时，需要一个个去替换
如果形成了依赖链路A->B->C->D，如果要修改A 那么BCD都要修改，这样耦合性太强

di只是实现ioc的一种方式，java使用依赖注入是因为之前没有lambda表达式，只能依附于一个类
如果是函数式语言，函数作为一等公民的话，也就不需要di
其他方式例如回调函数、宏(编译器注入) 等方式都能实现控制反转
例如**设计模式中的模板模式和策略模式也有类似了控制反转**


依赖倒置DIP是设计原则之一：底层和上层都依赖于抽象 ，抽象不依赖于细节，细节依赖于抽象
类似于招投标，招标的人A指定规则，投标的人B负责具体实现，这样就从A依赖B，变为了B依赖A的抽象接口

从系统架构的层面看，
一个稳定易拓展的系统应该让底层依赖高层，而不是相反(高层依赖底层)，一个合理的系统，应该由高层按照自己的需求，指定底层应该满足的规范

实际开发中，为什么推荐构造器注入 而不是set注入
构造器注入的方式 **能够保证注入的组件不可变，并且确保需要的依赖不为空** 。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态
为什么构造器注入方式时注入了太多的类，这是因为类设计违反了单一职责


### 一句话总结
使用依赖注入实现了控制反转，体现了依赖倒置的设计原则



[(38 封私信 / 80 条消息) 为什么有很多人说 Go 语言不需要依赖注入？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/265433666)



最佳实践：
构造函数注入：
`final` 字段加 `@RequiredArgsConstructor`(自动生成带有 `final` 字段的构造函数) ，
它确保了类的依赖关系在创建时就被确定，提高了代码的**安全**性（保证依赖不为空 保证依赖不可变 避免循环依赖），**方便测试**
```
@Component
public class MyService {
    @Autowired
    private MyDependency myDependency;
}
@Component
public class MyService {
    private final MyDependency myDependency;

    @Autowired
    public MyService(MyDependency myDependency) {
        this.myDependency = myDependency;
    }
}

```
字段注入：
`@Autowired` 字段注入 ，依赖项可能为 `null` 这是缺点

疑问：如果依赖项过多是不是太复杂：此时应该思考为什么会这么多依赖项