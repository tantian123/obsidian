问题描述：
Redis与MySQL数据一致性问题
只能最终一致性

适用于缓存的场景：
适合读多写少的场景，例如昨日的排名或者是商品信息

在解决缓存一致性的问题时，要根据不同的业务场景，使用不同的更新策略
cache-aside
read through  直读
write through 直写
write back 写回   也称Write Behind延迟写入

在读多写少的场景下，可以选择cache-aside结合数据库日志做补偿的方案


#### 分析问题
本质还是并发问题，
从增删改查来分析 
增和查没有一致性问题
对于删来说，先删缓存再删数据库，此时如果有查询，缓存就会有数据，数据库中无数据
先删数据库再删缓存，还是会存在并发问题，但是最终一致的

对于更新，先更新数据库 再更新缓存，
T1线程更新数据库后，碰到机器GC，
T2线程更新数据库和缓存 ，T1再更新缓存，最终结果也是不一致的

可以，先更新数据库再删除缓存
T1线程更新数据库后，碰到机器GC，
T2线程更新数据库，删除缓存 ，T1再删除缓存
后续查询时就会将T2的值写入缓存

初始中缓存无数据
T1查询数据库，准备写缓存但是卡顿
T2 更新数据库 删除缓存
T1 恢复 写入缓存
后续查询的都是T1查询到的值


延迟双删（没有必要 实际不能落地）
在数据库更新后，延迟一段时间再次删除缓存，防止并发读导致旧数据回填
#### 最佳实践：
读Redis 写Mysql，同时监听Mysql的Binlog 然后异步刷新Redis
可以使用阿里的canal将binlog日志采集发送到MQ队列里面







**cache-aside**：读 先读缓存，如果命中，返回数据；如果没有，再读数据库并写入缓存中
写 先写入数据库  然后删除缓存
```
func find(key){
	data=cache.get(key)
	if(data==null){
		data=db.get(key)
		cache.set(key,data)
	}
	
}
func set(key,value){
	boolean res=db.set(key,value)
	if(res){
		cache.remove(key)
	}	
}
```


**Read/Write Through**模式中，服务端把缓存作为主要数据存储
和cache-aside基本一样，只是封装在缓存工具中
**区别是类似一个阻塞操作，只有全部返回才算完成**

**write back**
也是由缓存工具完成，但是只更新缓存，然后异步更新数据库，这种方式下，缓存和数据库的一致性不强（类似InnoDB的bufferpool）
**区别是类似一个异步操作，只有更新数据库是异步操作**